{
    "Basic Boilerplate": {
        "prefix": "ld_c",
        "body": [
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "",
            "static int __init hello_init(void) {",
            "    printk(KERN_INFO \"Hello, Kernel!\\n\");",
            "    return 0;",
            "}",
            "",
            "static void __exit hello_exit(void) {",
            "    printk(KERN_INFO \"Goodbye, Kernel!\\n\");",
            "}",
            "",
            "module_init(hello_init);",
            "module_exit(hello_exit);",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"A simple Hello World LKM\");"
        ],
        "description": "Minimal Linux Kernel Module"
    },
    "char_device": {
        "prefix": "ld_char",
        "body": [
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "",
            "#define DEVICE_NAME \"mychardev\"",
            "static int major;",
            "",
            "static int dev_open(struct inode *, struct file *);",
            "static int dev_release(struct inode *, struct file *);",
            "static ssize_t dev_read(struct file *, char *, size_t, loff_t *);",
            "static ssize_t dev_write(struct file *, const char *, size_t, loff_t *);",
            "",
            "static struct file_operations fops = {",
            "    .open = dev_open,",
            "    .read = dev_read,",
            "    .write = dev_write,",
            "    .release = dev_release,",
            "};",
            "",
            "static int __init char_init(void) {",
            "    major = register_chrdev(0, DEVICE_NAME, &fops);",
            "    if (major < 0) {",
            "        printk(KERN_ALERT \"Registering char device failed\\n\");",
            "        return major;",
            "    }",
            "    printk(KERN_INFO \"Registered char device with major number %d\\n\", major);",
            "    return 0;",
            "}",
            "",
            "static void __exit char_exit(void) {",
            "    unregister_chrdev(major, DEVICE_NAME);",
            "    printk(KERN_INFO \"Unregistered char device\\n\");",
            "}",
            "",
            "module_init(char_init);",
            "module_exit(char_exit);",
            "",
            "MODULE_LICENSE(\"GPL\");"
        ],
        "description": "Character Device Skeleton"
    },
    "ld_dt_probe_driver": {
        "prefix": "ld_dt_probe",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/property.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/of_device.h>",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"mmkumr\");",
            "MODULE_DESCRIPTION(\"Device tree probe driver\");",
            "",
            "static int ${1:dt_probe}(struct platform_device *pdev);",
            "static int ${2:dt_remove}(struct platform_device *pdev);",
            "",
            "static const struct of_device_id ${3:my_driver_ids}[] = {",
            "    { .compatible = \"${4:brightlight,mydev}\" },",
            "    { /* sentinel */ }",
            "};",
            "MODULE_DEVICE_TABLE(of, ${3:my_driver_ids});",
            "",
            "static struct platform_driver ${5:my_driver} = {",
            "    .probe = ${1:dt_probe},",
            "    .remove = ${2:dt_remove},",
            "    .driver = {",
            "        .name = \"${6:my_device_driver}\",",
            "        .of_match_table = ${3:my_driver_ids},",
            "    },",
            "};",
            "",
            "static int ${1:dt_probe}(struct platform_device *pdev) {",
            "    struct device *dev = &pdev->dev;",
            "    const char *label;",
            "    int my_value, ret;",
            "",
            "    dev_info(dev, \"Probing device...\\n\");",
            "",
            "    if (!device_property_present(dev, \"label\")) {",
            "        dev_err(dev, \"Property 'label' not found\\n\");",
            "        return -EINVAL;",
            "    }",
            "    if (!device_property_present(dev, \"my_value\")) {",
            "        dev_err(dev, \"Property 'my_value' not found\\n\");",
            "        return -EINVAL;",
            "    }",
            "",
            "    ret = device_property_read_string(dev, \"label\", &label);",
            "    if (ret) {",
            "        dev_err(dev, \"Failed to read 'label'\\n\");",
            "        return ret;",
            "    }",
            "    dev_info(dev, \"label = %s\\n\", label);",
            "",
            "    ret = device_property_read_u32(dev, \"my_value\", &my_value);",
            "    if (ret) {",
            "        dev_err(dev, \"Failed to read 'my_value'\\n\");",
            "        return ret;",
            "    }",
            "    dev_info(dev, \"my_value = %d\\n\", my_value);",
            "",
            "    return 0;",
            "}",
            "",
            "static int ${2:dt_remove}(struct platform_device *pdev) {",
            "    dev_info(&pdev->dev, \"Removing device\\n\");",
            "    return 0;",
            "}",
            "",
            "static int __init ${7:my_init}(void) {",
            "    pr_info(\"Loading device tree probe driver\\n\");",
            "    return platform_driver_register(&${5:my_driver});",
            "}",
            "",
            "static void __exit ${8:my_exit}(void) {",
            "    pr_info(\"Unloading device tree probe driver\\n\");",
            "    platform_driver_unregister(&${5:my_driver});",
            "}",
            "",
            "module_init(${7:my_init});",
            "module_exit(${8:my_exit});"
        ],
        "description": "Device tree probe kernel module with label and my_value properties"
    },
    "i2c_driver": {
        "prefix": "ld_i2c",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/i2c.h>",
            "",
            "static int my_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id) {",
            "    dev_info(&client->dev, \"I2C device probed\\n\");",
            "    return 0;",
            "}",
            "",
            "static int my_i2c_remove(struct i2c_client *client) {",
            "    dev_info(&client->dev, \"I2C device removed\\n\");",
            "    return 0;",
            "}",
            "",
            "static const struct i2c_device_id my_i2c_id[] = {",
            "    { \"my_i2c_device\", 0 },",
            "    { }",
            "};",
            "MODULE_DEVICE_TABLE(i2c, my_i2c_id);",
            "",
            "static struct i2c_driver my_i2c_driver = {",
            "    .driver = {",
            "        .name = \"my_i2c_driver\",",
            "    },",
            "    .probe = my_i2c_probe,",
            "    .remove = my_i2c_remove,",
            "    .id_table = my_i2c_id,",
            "};",
            "",
            "module_i2c_driver(my_i2c_driver);",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"A simple I2C Driver\");"
        ],
        "description": "Basic I2C Device Driver"
    },
    "ld_i2c_proc": {
        "prefix": "ld_i2c_proc",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/i2c.h>",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"${1:mmkumr}\");",
            "MODULE_DESCRIPTION(\"${2:A driver for my simple AMTEGA I2C ADC}\");",
            "",
            "static struct i2c_client *adc_client;",
            "static struct proc_dir_entry *proc_file;",
            "",
            "static ssize_t my_write(struct file *File, const char *user_buffer, size_t count, loff_t *offs) {",
            "    long val;",
            "    if (0 == kstrtol(user_buffer, 0, &val))",
            "        i2c_smbus_write_byte(adc_client, (u8) val);",
            "    return count;",
            "}",
            "",
            "static ssize_t my_read(struct file *File, char *user_buffer, size_t count, loff_t *offs) {",
            "    u8 adc;",
            "    adc = i2c_smbus_read_byte(adc_client);",
            "    return sprintf(user_buffer, \"%d\\n\", adc);",
            "}",
            "",
            "static struct proc_ops fops = {",
            "    .proc_write = my_write,",
            "    .proc_read = my_read,",
            "};",
            "",
            "static int my_adc_probe(struct i2c_client *client, const struct i2c_device_id *id) {",
            "    printk(\"dt_i2c - Now I am in the Probe function!\\n\");",
            "    if (client->addr != 0x${3:10}) {",
            "        printk(\"dt_i2c - Wrong I2C address!\\n\");",
            "        return -1;",
            "    }",
            "    adc_client = client;",
            "    proc_file = proc_create(\"${4:myadc}\", 0666, NULL, &fops);",
            "    if (proc_file == NULL) {",
            "        printk(\"dt_i2c - Error creating /proc/${4:myadc}\\n\");",
            "        return -ENOMEM;",
            "    }",
            "    return 0;",
            "}",
            "",
            "static int my_adc_remove(struct i2c_client *client) {",
            "    printk(\"dt_i2c - Now I am in the Remove function!\\n\");",
            "    proc_remove(proc_file);",
            "    return 0;",
            "}",
            "",
            "static struct of_device_id my_driver_ids[] = {",
            "    { .compatible = \"${5:brightlight,myadc}\", },",
            "    { /* sentinel */ }",
            "};",
            "MODULE_DEVICE_TABLE(of, my_driver_ids);",
            "",
            "static struct i2c_device_id my_adc[] = {",
            "    {\"${6:my_adc}\", 0},",
            "    { },",
            "};",
            "MODULE_DEVICE_TABLE(i2c, my_adc);",
            "",
            "static struct i2c_driver my_driver = {",
            "    .probe = my_adc_probe,",
            "    .remove = my_adc_remove,",
            "    .id_table = my_adc,",
            "    .driver = {",
            "        .name = \"${6:my_adc}\",",
            "        .of_match_table = my_driver_ids,",
            "    },",
            "};",
            "",
            "module_i2c_driver(my_driver);"
        ],
        "description": "I2C kernel driver with procfs read/write and device tree support"
    },
    "Linux I2C IIO ADC Driver": {
        "prefix": "ld_i2c_iio",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/i2c.h>",
            "#include <linux/iio/iio.h>",
            "#include <linux/iio/sysfs.h>",
            "",
            "#define CMD_GET_STATE 0x11",
            "#define CMD_SET_STATE 0x22",
            "#define CMD_GET_ADC_VAL 0x55",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"${1:Your Name}\");",
            "MODULE_DESCRIPTION(\"A driver for ${2:my I2C ADC using IIO}\");",
            "",
            "struct ${3:my_adc} {",
            "    struct i2c_client *client;",
            "};",
            "",
            "static int ${3}_read_raw(struct iio_dev *indio_dev,",
            "                         struct iio_chan_spec const *chan,",
            "                         int *val, int *val2, long mask) {",
            "    struct ${3} *adc = iio_priv(indio_dev);",
            "    int ret;",
            "",
            "    if (mask == IIO_CHAN_INFO_RAW) {",
            "        ret = i2c_smbus_read_byte_data(adc->client, CMD_GET_ADC_VAL);",
            "        if (ret < 0) {",
            "            pr_err(\"${3} - Failed to read ADC value\\n\");",
            "            return ret;",
            "        }",
            "        *val = ret;",
            "        return IIO_VAL_INT;",
            "    }",
            "    return -EINVAL;",
            "}",
            "",
            "static const struct iio_chan_spec ${3}_channels[] = {",
            "    {",
            "        .type = IIO_VOLTAGE,",
            "        .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),",
            "    }",
            "};",
            "",
            "static const struct iio_info ${3}_info = {",
            "    .read_raw = ${3}_read_raw,",
            "};",
            "",
            "static int ${3}_probe(struct i2c_client *client, const struct i2c_device_id *id) {",
            "    struct iio_dev *indio_dev;",
            "    struct ${3} *adc;",
            "    int ret;",
            "",
            "    pr_info(\"${3} - Probing I2C ADC driver\\n\");",
            "",
            "    indio_dev = devm_iio_device_alloc(&client->dev, sizeof(struct ${3}));",
            "    if (!indio_dev)",
            "        return -ENOMEM;",
            "",
            "    adc = iio_priv(indio_dev);",
            "    adc->client = client;",
            "",
            "    indio_dev->name = id->name;",
            "    indio_dev->info = &${3}_info;",
            "    indio_dev->modes = INDIO_DIRECT_MODE;",
            "    indio_dev->channels = ${3}_channels;",
            "    indio_dev->num_channels = ARRAY_SIZE(${3}_channels);",
            "",
            "    ret = i2c_smbus_write_byte_data(adc->client, CMD_SET_STATE, 0x1);",
            "    if (ret < 0) {",
            "        pr_err(\"${3} - Failed to power up device\\n\");",
            "        return ret;",
            "    }",
            "",
            "    i2c_set_clientdata(client, indio_dev);",
            "",
            "    return devm_iio_device_register(&client->dev, indio_dev);",
            "}",
            "",
            "static int ${3}_remove(struct i2c_client *client) {",
            "    struct iio_dev *indio_dev = i2c_get_clientdata(client);",
            "    struct ${3} *adc = iio_priv(indio_dev);",
            "",
            "    pr_info(\"${3} - Removing driver and powering down\\n\");",
            "    i2c_smbus_write_byte_data(adc->client, CMD_SET_STATE, 0x0);",
            "    return 0;",
            "}",
            "",
            "static const struct of_device_id ${3}_of_match[] = {",
            "    { .compatible = \"${4:brightlight,myadc}\" },",
            "    { }",
            "};",
            "MODULE_DEVICE_TABLE(of, ${3}_of_match);",
            "",
            "static const struct i2c_device_id ${3}_id[] = {",
            "    { \"${5:my_adc}\", 0 },",
            "    { }",
            "};",
            "MODULE_DEVICE_TABLE(i2c, ${3}_id);",
            "",
            "static struct i2c_driver ${3}_driver = {",
            "    .driver = {",
            "        .name = \"${5:my_adc}\",",
            "        .of_match_table = ${3}_of_match,",
            "    },",
            "    .probe = ${3}_probe,",
            "    .remove = ${3}_remove,",
            "    .id_table = ${3}_id,",
            "};",
            "",
            "module_i2c_driver(${3}_driver);"
        ],
        "description": "I2C IIO ADC driver with device tree support and IIO sysfs interface"
    },
    "Linux SPI Driver Latest": {
        "prefix": "ld_spi",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/spi/spi.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/of.h>",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"${1:Your Name}\");",
            "MODULE_DESCRIPTION(\"SPI device driver using latest kernel API\");",
            "",
            "static int ${2:spi_dev}_probe(struct spi_device *spi) {",
            "    int ret;",
            "    u8 tx_buf[2] = { 0x75, 0x40 };",
            "    u8 rx_buf[1];",
            "    struct spi_transfer t[] = {",
            "        {",
            "            .tx_buf = tx_buf,",
            "            .len = 1,",
            "        },",
            "        {",
            "            .rx_buf = rx_buf,",
            "            .len = 1,",
            "        }",
            "    };",
            "    struct spi_message m;",
            "",
            "    spi->bits_per_word = 8;",
            "    ret = spi_setup(spi);",
            "    if (ret) {",
            "        dev_err(&spi->dev, \"Failed to setup SPI device: %d\\n\", ret);",
            "        return ret;",
            "    }",
            "",
            "    spi_message_init(&m);",
            "    spi_message_add_tail(&t[0], &m);",
            "    spi_message_add_tail(&t[1], &m);",
            "",
            "    ret = spi_sync(spi, &m);",
            "    if (ret) {",
            "        dev_err(&spi->dev, \"SPI transfer failed: %d\\n\", ret);",
            "        return ret;",
            "    }",
            "",
            "    dev_info(&spi->dev, \"Chip ID read: 0x%02x\\n\", rx_buf[0]);",
            "",
            "    return 0;",
            "}",
            "",
            "static int ${2:spi_dev}_remove(struct spi_device *spi) {",
            "    dev_info(&spi->dev, \"Removing SPI device\\n\");",
            "    return 0;",
            "}",
            "",
            "static const struct of_device_id ${2:spi_dev}_of_match[] = {",
            "    { .compatible = \"bosch,bmp280\", },",
            "    { }",
            "};",
            "MODULE_DEVICE_TABLE(of, ${2:spi_dev}_of_match);",
            "",
            "static struct spi_driver ${2:spi_dev}_driver = {",
            "    .driver = {",
            "        .name = \"${2:spi_dev}\",",
            "        .of_match_table = ${2:spi_dev}_of_match,",
            "    },",
            "    .probe = ${2:spi_dev}_probe,",
            "    .remove = ${2:spi_dev}_remove,",
            "};",
            "",
            "module_spi_driver(${2:spi_dev}_driver);"
        ],
        "description": "SPI driver using probe/remove and spi_sync for latest kernel"
    },
    "ld_spi_driver": {
        "prefix": "ld_spi_proc",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/spi/spi.h>",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"${1:mmkumr}\");",
            "MODULE_DESCRIPTION(\"${2:A driver for my simple SPI ADC}\");",
            "",
            "static struct spi_device *adc_spi_device;",
            "static struct proc_dir_entry *proc_file;",
            "",
            "static ssize_t my_write(struct file *file, const char __user *user_buffer, size_t count, loff_t *offs) {",
            "    char buf[16];",
            "    int ret;",
            "    u8 val;",
            "    if (count > sizeof(buf) - 1)",
            "        return -EINVAL;",
            "    if (copy_from_user(buf, user_buffer, count))",
            "        return -EFAULT;",
            "    buf[count] = '\\0';",
            "    ret = kstrtou8(buf, 0, &val);",
            "    if (ret)",
            "        return ret;",
            "",
            "    ret = spi_write(adc_spi_device, &val, 1);",
            "    if (ret < 0)",
            "        return ret;",
            "",
            "    return count;",
            "}",
            "",
            "static ssize_t my_read(struct file *file, char __user *user_buffer, size_t count, loff_t *offs) {",
            "    u8 val = 0;",
            "    char buf[16];",
            "    int ret;",
            "",
            "    ret = spi_read(adc_spi_device, &val, 1);",
            "    if (ret < 0)",
            "        return ret;",
            "",
            "    ret = snprintf(buf, sizeof(buf), \"%d\\n\", val);",
            "    if (ret < 0)",
            "        return ret;",
            "",
            "    if (*offs > 0)",
            "        return 0;  // EOF",
            "",
            "    if (copy_to_user(user_buffer, buf, ret))",
            "        return -EFAULT;",
            "",
            "    *offs += ret;",
            "    return ret;",
            "}",
            "",
            "static struct proc_ops fops = {",
            "    .proc_write = my_write,",
            "    .proc_read = my_read,",
            "};",
            "",
            "static int my_spi_probe(struct spi_device *spi) {",
            "    printk(\"dt_spi - In probe function\\n\");",
            "    adc_spi_device = spi;",
            "    proc_file = proc_create(\"${3:myspi}\", 0666, NULL, &fops);",
            "    if (!proc_file) {",
            "        printk(\"dt_spi - Error creating /proc/${3:myspi}\\n\");",
            "        return -ENOMEM;",
            "    }",
            "    return 0;",
            "}",
            "",
            "static int my_spi_remove(struct spi_device *spi) {",
            "    printk(\"dt_spi - In remove function\\n\");",
            "    proc_remove(proc_file);",
            "    return 0;",
            "}",
            "",
            "static const struct of_device_id my_driver_ids[] = {",
            "    { .compatible = \"${4:brightlight,myspi}\", },",
            "    { }",
            "};",
            "MODULE_DEVICE_TABLE(of, my_driver_ids);",
            "",
            "static struct spi_driver my_spi_driver = {",
            "    .driver = {",
            "        .name = \"${5:my_spi_adc}\",",
            "        .of_match_table = my_driver_ids,",
            "    },",
            "    .probe = my_spi_probe,",
            "    .remove = my_spi_remove,",
            "};",
            "",
            "module_spi_driver(my_spi_driver);"
        ],
        "description": "SPI kernel driver with procfs read/write and device tree support"
    },
    "SPI IIO ADC Driver Skeleton": {
        "prefix": "ld_spi_iio",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/spi/spi.h>",
            "#include <linux/iio/iio.h>",
            "#include <linux/iio/sysfs.h>",
            "",
            "#define CMD_GET_STATE 0x11",
            "#define CMD_SET_STATE 0x22",
            "#define CMD_GET_ADC_VAL 0x55",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"${1:Your Name}\");",
            "MODULE_DESCRIPTION(\"A driver for my SPI ADC\");",
            "",
            "struct ${2:my_adc} {",
            "  struct spi_device *client;",
            "};",
            "",
            "static int ${2}_read_raw(struct iio_dev *indio_dev,",
            "  struct iio_chan_spec const *chan, int *val, int *val2, long mask) {",
            "  struct ${2} *adc = iio_priv(indio_dev);",
            "  int ret;",
            "  if (mask == IIO_CHAN_INFO_RAW) {",
            "    ret = spi_w8r8(adc->client, CMD_GET_ADC_VAL);",
            "    if (ret < 0) return ret;",
            "    *val = ret;",
            "    return IIO_VAL_INT;",
            "  }",
            "  return -EINVAL;",
            "}",
            "",
            "static const struct iio_chan_spec ${2}_channels[] = {",
            "  {",
            "    .type = IIO_VOLTAGE,",
            "    .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),",
            "  },",
            "};",
            "",
            "static const struct iio_info ${2}_info = {",
            "  .read_raw = ${2}_read_raw,",
            "};",
            "",
            "static int ${2}_probe(struct spi_device *client) {",
            "  struct iio_dev *indio_dev;",
            "  struct ${2} *adc;",
            "  int ret;",
            "  u8 buffer[2];",
            "",
            "  indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*adc));",
            "  if (!indio_dev) return -ENOMEM;",
            "",
            "  adc = iio_priv(indio_dev);",
            "  adc->client = client;",
            "",
            "  indio_dev->name = \"${3:myadc}\";",
            "  indio_dev->info = &${2}_info;",
            "  indio_dev->modes = INDIO_DIRECT_MODE;",
            "  indio_dev->channels = ${2}_channels;",
            "  indio_dev->num_channels = ARRAY_SIZE(${2}_channels);",
            "",
            "  ret = spi_setup(client);",
            "  if (ret < 0) return ret;",
            "",
            "  buffer[0] = CMD_SET_STATE;",
            "  buffer[1] = 0x1;",
            "  ret = spi_write(adc->client, buffer, 2);",
            "  if (ret < 0) return ret;",
            "",
            "  spi_set_drvdata(client, indio_dev);",
            "  return devm_iio_device_register(&client->dev, indio_dev);",
            "}",
            "",
            "static int ${2}_remove(struct spi_device *client) {",
            "  struct iio_dev *indio_dev = spi_get_drvdata(client);",
            "  struct ${2} *adc = iio_priv(indio_dev);",
            "  u8 buffer[2] = {CMD_SET_STATE, 0x0};",
            "  return spi_write(adc->client, buffer, 2);",
            "}",
            "",
            "static const struct of_device_id ${2}_of_match[] = {",
            "  { .compatible = \"${4:brightlight,myadc}\" },",
            "  { },",
            "};",
            "MODULE_DEVICE_TABLE(of, ${2}_of_match);",
            "",
            "static const struct spi_device_id ${2}_id[] = {",
            "  { \"${3}\", 0 },",
            "  { },",
            "};",
            "MODULE_DEVICE_TABLE(spi, ${2}_id);",
            "",
            "static struct spi_driver ${2}_driver = {",
            "  .probe = ${2}_probe,",
            "  .remove = ${2}_remove,",
            "  .driver = {",
            "    .name = \"${3}\",",
            "    .of_match_table = ${2}_of_match,",
            "  },",
            "  .id_table = ${2}_id,",
            "};",
            "",
            "module_spi_driver(${2}_driver);"
        ],
        "description": "Skeleton SPI IIO ADC driver with configurable names and compatible string"
    },
    "High-Resolution Timer Kernel Module": {
        "prefix": "ld_hrtimer",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/jiffies.h>",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"${1:Your Name}\");",
            "MODULE_DESCRIPTION(\"${2:A simple LKM using High Resolution Timers}\");",
            "",
            "static struct hrtimer ${3:my_hrtimer};",
            "u64 ${4:start_t};",
            "",
            "static enum hrtimer_restart ${5:hrtimer_handler}(struct hrtimer *timer) {",
            "  u64 now_t = jiffies;",
            "  printk(KERN_INFO \"start_t - now_t = %u ms\\n\", jiffies_to_msecs(now_t - ${4:start_t}));",
            "  return HRTIMER_NORESTART;",
            "}",
            "",
            "static int __init ${6:ModuleInit}(void) {",
            "  printk(KERN_INFO \"Hello, Kernel!\\n\");",
            "",
            "  hrtimer_init(&${3:my_hrtimer}, CLOCK_MONOTONIC, HRTIMER_MODE_REL);",
            "  ${3:my_hrtimer}.function = &${5:hrtimer_handler};",
            "  ${4:start_t} = jiffies;",
            "  hrtimer_start(&${3:my_hrtimer}, ms_to_ktime(${7:100}), HRTIMER_MODE_REL);",
            "",
            "  return 0;",
            "}",
            "",
            "static void __exit ${8:ModuleExit}(void) {",
            "  hrtimer_cancel(&${3:my_hrtimer});",
            "  printk(KERN_INFO \"Goodbye, Kernel\\n\");",
            "}",
            "",
            "module_init(${6:ModuleInit});",
            "module_exit(${8:ModuleExit});"
        ],
        "description": "Linux kernel module using hrtimer with printk and ms delay"
    },
    "ld_rwop": {
        "prefix": "ld_rwop",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include <linux/cdev.h>",
            "#include <linux/device.h>",
            "",
            "static dev_t dev;",
            "static struct cdev my_cdev;",
            "static struct class *dev_class;",
            "static struct device *dev_device;",
            "",
            "char kbuf[128] = \"Hello from kernel!\";",
            "",
            "static int my_open(struct inode *inode, struct file *file) {",
            "    printk(KERN_INFO \"Device opened\\n\");",
            "    return 0;",
            "}",
            "",
            "static int my_release(struct inode *inode, struct file *file) {",
            "    printk(KERN_INFO \"Device released\\n\");",
            "    return 0;",
            "}",
            "",
            "static ssize_t my_read(struct file *file, char __user *buf, size_t len, loff_t *offset) {",
            "    int datalen = sizeof(kbuf);",
            "    if (*offset >= datalen) return 0;",
            "    if (len > datalen - *offset) len = datalen - *offset;",
            "    if (copy_to_user(buf, kbuf + *offset, len)) return -EFAULT;",
            "    *offset += len;",
            "    return len;",
            "}",
            "",
            "static ssize_t my_write(struct file *file, const char __user *buf, size_t len, loff_t *offset) {",
            "    if (len > 127) len = 127;",
            "    if (copy_from_user(kbuf, buf, len)) return -EFAULT;",
            "    kbuf[len] = '\\0';",
            "    printk(KERN_INFO \"Received from user: %s\\n\", kbuf);",
            "    return len;",
            "}",
            "",
            "static struct file_operations fops = {",
            "    .owner = THIS_MODULE,",
            "    .open = my_open,",
            "    .release = my_release,",
            "    .read = my_read,",
            "    .write = my_write,",
            "};",
            "",
            "static int __init my_init(void) {",
            "    alloc_chrdev_region(&dev, 0, 1, \"my_rwdev\");",
            "    cdev_init(&my_cdev, &fops);",
            "    cdev_add(&my_cdev, dev, 1);",
            "",
            "    dev_class = class_create(THIS_MODULE, \"rw_class\");",
            "    dev_device = device_create(dev_class, NULL, dev, NULL, \"rw_dev\");",
            "",
            "    printk(KERN_INFO \"Device registered: Major=%d Minor=%d\\n\", MAJOR(dev), MINOR(dev));",
            "    return 0;",
            "}",
            "",
            "static void __exit my_exit(void) {",
            "    device_destroy(dev_class, dev);",
            "    class_destroy(dev_class);",
            "    cdev_del(&my_cdev);",
            "    unregister_chrdev_region(dev, 1);",
            "    printk(KERN_INFO \"Device unregistered\\n\");",
            "}",
            "",
            "module_init(my_init);",
            "module_exit(my_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"Read, Write, Open, Release file operations with device node creation\");"
        ],
        "description": "Read, write, open, release function definitions and file_operations struct with device node creation"
    },
    "ld_userspace_rw": {
        "prefix": "ld_rwop_userspace",
        "body": [
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "",
            "#define DEVICE_PATH \"/dev/rw_dev\"",
            "",
            "int main() {",
            "    int fd;",
            "    char write_buf[100] = \"Hello Kernel from User!\";",
            "    char read_buf[100];",
            "",
            "    // Open the device file",
            "    fd = open(DEVICE_PATH, O_RDWR);",
            "    if (fd < 0) {",
            "        perror(\"Failed to open the device\");",
            "        return EXIT_FAILURE;",
            "    }",
            "",
            "    // Write to the device",
            "    if (write(fd, write_buf, strlen(write_buf)) < 0) {",
            "        perror(\"Failed to write to the device\");",
            "        close(fd);",
            "        return EXIT_FAILURE;",
            "    }",
            "    printf(\"Data written: %s\\n\", write_buf);",
            "",
            "    // Read from the device",
            "    memset(read_buf, 0, sizeof(read_buf));",
            "    if (read(fd, read_buf, sizeof(read_buf)) < 0) {",
            "        perror(\"Failed to read from the device\");",
            "        close(fd);",
            "        return EXIT_FAILURE;",
            "    }",
            "    printf(\"Data read: %s\\n\", read_buf);",
            "",
            "    close(fd);",
            "    return EXIT_SUCCESS;",
            "}"
        ],
        "description": "Userspace program to perform read/write on a character device file."
    },
    "File IO Kernel Module": {
        "prefix": "ld_file_io",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"${1:Your Name}\");",
            "MODULE_DESCRIPTION(\"${2:File read/write from kernel space}\");",
            "",
            "static int __init ${3:my_init}(void) {",
            "  struct file *file;",
            "  char data[${4:128}] = \"${5:Hey, careful, man, there's beverage here! - Dude}\\n\";",
            "  ssize_t len;",
            "",
            "  file = filp_open(\"${6:/tmp/dude}\", O_RDWR | O_CREAT, 0644);",
            "  if (IS_ERR(file)) {",
            "    printk(KERN_ERR \"file_io - Error opening file\\n\");",
            "    return PTR_ERR(file);",
            "  }",
            "",
            "  len = kernel_write(file, data, sizeof(data), &file->f_pos);",
            "  if (len < 0) {",
            "    printk(KERN_ERR \"file_io - Error writing: %zd\\n\", len);",
            "    filp_close(file, NULL);",
            "    return len;",
            "  }",
            "  printk(KERN_INFO \"file_io - Wrote %zd bytes\\n\", len);",
            "",
            "  memset(data, 0, sizeof(data));",
            "  file->f_pos = 0;",
            "",
            "  len = kernel_read(file, data, sizeof(data), &file->f_pos);",
            "  if (len < 0) {",
            "    printk(KERN_ERR \"file_io - Error reading: %zd\\n\", len);",
            "    filp_close(file, NULL);",
            "    return len;",
            "  }",
            "",
            "  printk(KERN_INFO \"file_io - Read %zd bytes: '%s'\\n\", len, data);",
            "  filp_close(file, NULL);",
            "",
            "  return 0;",
            "}",
            "",
            "static void __exit ${7:my_exit}(void) {",
            "  printk(KERN_INFO \"file_io - Module exit\\n\");",
            "}",
            "",
            "module_init(${3:my_init});",
            "module_exit(${7:my_exit});"
        ],
        "description": "LKM for reading and writing a file in /tmp"
    },
    "ld_gpio": {
        "prefix": "ld_gpio",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gpio.h>",
            "#include <linux/init.h>",
            "\n",
            "#define GPIO_NUM 24 // Replace with your GPIO number",
            "\n",
            "static int __init gpio_init(void) {",
            "  int ret;",
            "\n",
            "  ret = gpio_request(GPIO_NUM, \"my_gpio\");",
            "  if (ret) {",
            "    printk(KERN_ERR \"Failed to request GPIO %d\\n\", GPIO_NUM);",
            "    return ret;",
            "  }",
            "\n",
            "  ret = gpio_direction_output(GPIO_NUM, 1);",
            "  if (ret) {",
            "    printk(KERN_ERR \"Failed to set GPIO direction\\n\");",
            "    gpio_free(GPIO_NUM);",
            "    return ret;",
            "  }",
            "\n",
            "  printk(KERN_INFO \"GPIO %d initialized\\n\", GPIO_NUM);",
            "  return 0;",
            "}",
            "\n",
            "static void __exit gpio_exit(void) {",
            "  gpio_set_value(GPIO_NUM, 0);",
            "  gpio_free(GPIO_NUM);",
            "  printk(KERN_INFO \"GPIO %d released\\n\", GPIO_NUM);",
            "}",
            "\n",
            "module_init(gpio_init);",
            "module_exit(gpio_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"GPIO Driver Skeleton\");"
        ],
        "description": "GPIO driver skeleton for basic GPIO operations."
    },
    "GPIO Interrupt Handler": {
        "prefix": "ld_gpio_irq",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/gpio.h>",
            "#include <linux/interrupt.h>",
            "",
            "#define GPIO_IN ${1:17} // Replace with your GPIO pin number",
            "static unsigned int gpio_irq_number;",
            "",
            "static irqreturn_t gpio_irq_handler(int irq, void *dev_id) {",
            "    printk(KERN_INFO \"GPIO Interrupt occurred!\\n\");",
            "    return IRQ_HANDLED;",
            "}",
            "",
            "static int __init gpio_irq_init(void) {",
            "    int result = 0;",
            "",
            "    if (!gpio_is_valid(GPIO_IN)) {",
            "        printk(KERN_ERR \"Invalid GPIO %d\\n\", GPIO_IN);",
            "        return -ENODEV;",
            "    }",
            "",
            "    gpio_request(GPIO_IN, \"sysfs\");",
            "    gpio_direction_input(GPIO_IN);",
            "    gpio_irq_number = gpio_to_irq(GPIO_IN);",
            "    printk(KERN_INFO \"GPIO mapped to IRQ: %d\\n\", gpio_irq_number);",
            "",
            "    result = request_irq(gpio_irq_number,",
            "                         (irq_handler_t) gpio_irq_handler,",
            "                         IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,",
            "                         \"gpio_irq_handler\",",
            "                         NULL);",
            "",
            "    if (result) {",
            "        printk(KERN_ERR \"IRQ request failed\\n\");",
            "        gpio_unexport(GPIO_IN);",
            "        gpio_free(GPIO_IN);",
            "        return result;",
            "    }",
            "",
            "    printk(KERN_INFO \"GPIO IRQ module loaded\\n\");",
            "    return 0;",
            "}",
            "",
            "static void __exit gpio_irq_exit(void) {",
            "    free_irq(gpio_irq_number, NULL);",
            "    gpio_free(GPIO_IN);",
            "    printk(KERN_INFO \"GPIO IRQ module unloaded\\n\");",
            "}",
            "",
            "module_init(gpio_irq_init);",
            "module_exit(gpio_irq_exit);",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"GPIO Interrupt Handler Kernel Module\");"
        ],
        "description": "GPIO interrupt-based kernel module skeleton"
    },
    "dt_gpio_module": {
        "prefix": "ld_gpio_dt_proc",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/property.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gpio/consumer.h>",
            "#include <linux/proc_fs.h>",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"${1:Your Name}\");",
            "MODULE_DESCRIPTION(\"A simple LKM to parse the device tree for GPIO and properties\");",
            "",
            "static int dt_probe(struct platform_device *pdev);",
            "static int dt_remove(struct platform_device *pdev);",
            "",
            "static struct of_device_id my_driver_ids[] = {",
            "  { .compatible = \"${2:brightlight,mydev}\" },",
            "  { }",
            "};",
            "MODULE_DEVICE_TABLE(of, my_driver_ids);",
            "",
            "static struct platform_driver my_driver = {",
            "  .probe = dt_probe,",
            "  .remove = dt_remove,",
            "  .driver = {",
            "    .name = \"${3:my_device_driver}\",",
            "    .of_match_table = my_driver_ids,",
            "  },",
            "};",
            "",
            "static struct gpio_desc *my_led = NULL;",
            "static struct proc_dir_entry *proc_file;",
            "",
            "static ssize_t my_write(struct file *File, const char *user_buffer, size_t count, loff_t *offs) {",
            "  switch (user_buffer[0]) {",
            "    case '0':",
            "    case '1':",
            "      gpiod_set_value(my_led, user_buffer[0] - '0');",
            "    default:",
            "      break;",
            "  }",
            "  return count;",
            "}",
            "",
            "static struct proc_ops fops = {",
            "  .proc_write = my_write,",
            "};",
            "",
            "static int dt_probe(struct platform_device *pdev) {",
            "  struct device *dev = &pdev->dev;",
            "  const char *label;",
            "  int my_value, ret;",
            "",
            "  printk(\"dt_gpio - Probe function called\\n\");",
            "",
            "  if (!device_property_present(dev, \"label\") ||",
            "      !device_property_present(dev, \"my_value\") ||",
            "      !device_property_present(dev, \"green-led-gpio\")) {",
            "    printk(\"dt_gpio - Missing required DT properties\\n\");",
            "    return -EINVAL;",
            "  }",
            "",
            "  ret = device_property_read_string(dev, \"label\", &label);",
            "  if (ret) return ret;",
            "  printk(\"dt_gpio - label: %s\\n\", label);",
            "",
            "  ret = device_property_read_u32(dev, \"my_value\", &my_value);",
            "  if (ret) return ret;",
            "  printk(\"dt_gpio - my_value: %d\\n\", my_value);",
            "",
            "  my_led = gpiod_get(dev, \"green-led\", GPIOD_OUT_LOW);",
            "  if (IS_ERR(my_led)) return PTR_ERR(my_led);",
            "",
            "  proc_file = proc_create(\"my-led\", 0666, NULL, &fops);",
            "  if (!proc_file) {",
            "    gpiod_put(my_led);",
            "    return -ENOMEM;",
            "  }",
            "",
            "  return 0;",
            "}",
            "",
            "static int dt_remove(struct platform_device *pdev) {",
            "  printk(\"dt_gpio - Remove function called\\n\");",
            "  gpiod_put(my_led);",
            "  proc_remove(proc_file);",
            "  return 0;",
            "}",
            "",
            "static int __init my_init(void) {",
            "  printk(\"dt_gpio - Loading driver\\n\");",
            "  return platform_driver_register(&my_driver);",
            "}",
            "",
            "static void __exit my_exit(void) {",
            "  printk(\"dt_gpio - Unloading driver\\n\");",
            "  platform_driver_unregister(&my_driver);",
            "}",
            "",
            "module_init(my_init);",
            "module_exit(my_exit);"
        ],
        "description": "GPIO + DT probe kernel module with proc interface"
    },
    "ld_pwm": {
        "prefix": "ld_pwm",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/pwm.h>",
            "#include <linux/err.h>",
            "\n",
            "static struct pwm_device *pwm;",
            "\n",
            "static int __init pwm_dev_init(void) {",
            "  int ret;",
            "  pwm = pwm_request(0, \"my_pwm\");",
            "  if (IS_ERR(pwm)) {",
            "    pr_err(\"Failed to request PWM\\n\");",
            "    return PTR_ERR(pwm);",
            "  }",
            "  ret = pwm_config(pwm, 500000, 1000000);  // 50% duty cycle, 1ms period",
            "  if (ret < 0) {",
            "    pr_err(\"Failed to configure PWM\\n\");",
            "    pwm_free(pwm);",
            "    return ret;",
            "  }",
            "  pwm_enable(pwm);",
            "  pr_info(\"PWM enabled\\n\");",
            "  return 0;",
            "}",
            "\n",
            "static void __exit pwm_dev_exit(void) {",
            "  pwm_disable(pwm);",
            "  pwm_free(pwm);",
            "  pr_info(\"PWM disabled and freed\\n\");",
            "}",
            "\n",
            "module_init(pwm_dev_init);",
            "module_exit(pwm_dev_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"Simple PWM driver\");"
        ],
        "description": "Basic PWM driver using pwm_request, pwm_config, pwm_enable."
    },
    "ld_uart": {
        "prefix": "ld_uart",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/tty.h>",
            "#include <linux/tty_flip.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/platform_device.h>",
            "\n",
            "static struct uart_port my_uart_port;",
            "\n",
            "static int my_uart_startup(struct uart_port *port) {",
            "  pr_info(\"UART startup\\n\");",
            "  // Add hardware initialization here",
            "  return 0;",
            "}",
            "\n",
            "static void my_uart_shutdown(struct uart_port *port) {",
            "  pr_info(\"UART shutdown\\n\");",
            "  // Add hardware shutdown here",
            "}",
            "\n",
            "static unsigned int my_uart_tx_empty(struct uart_port *port) {",
            "  return TIOCSER_TEMT;  // Transmitter empty",
            "}",
            "\n",
            "static void my_uart_set_mctrl(struct uart_port *port, unsigned int mctrl) {",
            "  pr_info(\"UART set_mctrl: %u\\n\", mctrl);",
            "  // Control modem lines",
            "}",
            "\n",
            "static unsigned int my_uart_get_mctrl(struct uart_port *port) {",
            "  // Return modem status lines",
            "  return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;",
            "}",
            "\n",
            "static void my_uart_stop_tx(struct uart_port *port) {",
            "  pr_info(\"UART stop_tx\\n\");",
            "  // Stop transmitter",
            "}",
            "\n",
            "static void my_uart_start_tx(struct uart_port *port) {",
            "  pr_info(\"UART start_tx\\n\");",
            "  // Start transmitter",
            "}",
            "\n",
            "static void my_uart_stop_rx(struct uart_port *port) {",
            "  pr_info(\"UART stop_rx\\n\");",
            "  // Stop receiver",
            "}",
            "\n",
            "static void my_uart_enable_ms(struct uart_port *port) {",
            "  pr_info(\"UART enable_ms\\n\");",
            "  // Enable modem status interrupts",
            "}",
            "\n",
            "static void my_uart_set_termios(struct uart_port *port, struct ktermios *termios, struct ktermios *old) {",
            "  pr_info(\"UART set_termios\\n\");",
            "  // Set baud rate and other params",
            "}",
            "\n",
            "static const struct uart_ops my_uart_ops = {",
            "  .startup = my_uart_startup,",
            "  .shutdown = my_uart_shutdown,",
            "  .tx_empty = my_uart_tx_empty,",
            "  .set_mctrl = my_uart_set_mctrl,",
            "  .get_mctrl = my_uart_get_mctrl,",
            "  .stop_tx = my_uart_stop_tx,",
            "  .start_tx = my_uart_start_tx,",
            "  .stop_rx = my_uart_stop_rx,",
            "  .enable_ms = my_uart_enable_ms,",
            "  .set_termios = my_uart_set_termios,",
            "};",
            "\n",
            "static struct uart_driver my_uart_driver = {",
            "  .owner = THIS_MODULE,",
            "  .driver_name = \"my_uart_driver\",",
            "  .dev_name = \"ttyMY\",",
            "  .major = 0,",
            "  .minor = 0,",
            "  .nr = 1,",
            "};",
            "\n",
            "static int __init my_uart_init(void) {",
            "  int ret;",
            "  ret = uart_register_driver(&my_uart_driver);",
            "  if (ret) {",
            "    pr_err(\"Failed to register UART driver\\n\");",
            "    return ret;",
            "  }",
            "  memset(&my_uart_port, 0, sizeof(my_uart_port));",
            "  my_uart_port.ops = &my_uart_ops;",
            "  my_uart_port.iotype = UPIO_MEM;",
            "  my_uart_port.flags = UPF_BOOT_AUTOCONF;",
            "  my_uart_port.line = 0;",
            "  // Add additional port setup here",
            "  pr_info(\"UART driver initialized\\n\");",
            "  return 0;",
            "}",
            "\n",
            "static void __exit my_uart_exit(void) {",
            "  uart_unregister_driver(&my_uart_driver);",
            "  pr_info(\"UART driver exited\\n\");",
            "}",
            "\n",
            "module_init(my_uart_init);",
            "module_exit(my_uart_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"Basic UART driver skeleton\");"
        ],
        "description": "Basic UART driver skeleton implementing uart_ops."
    },
    "ld_ioctl": {
        "prefix": "ld_ioctl",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include <linux/cdev.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/device.h>",
            "",
            "// ioctl_func.h",
            "#ifndef IOCT_TEST_H",
            "#define IOCT_TEST_H",
            "struct my_struct {",
            "  int id;",
            "  char name[100];",
            "};",
            "#define WR_VALUE _IOW('a', 'b', int *)",
            "#define RD_VALUE _IOR('a', 'b', int *)",
            "#define Greeter  _IOW('a', 'c', struct my_struct *)",
            "#endif",
            "",
            "static dev_t dev;",
            "static struct cdev my_cdev;",
            "static struct class *dev_class;",
            "static struct device *dev_device;",
            "",
            "int value = 20;",
            "",
            "static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {",
            "  struct my_struct ioctl_struct;",
            "  switch (cmd) {",
            "    case WR_VALUE:",
            "      if (copy_from_user(&value, (int __user *)arg, sizeof(int)))",
            "        return -EFAULT;",
            "      printk(KERN_INFO \"Received IOCTL value: %d\\n\", value);",
            "      break;",
            "    case RD_VALUE:",
            "      if (copy_to_user((int __user *)arg, &value, sizeof(int)))",
            "        return -EFAULT;",
            "      printk(KERN_INFO \"Sent IOCTL value: %d\\n\", value);",
            "      break;",
            "    case Greeter:",
            "      if (copy_from_user(&ioctl_struct, (struct my_struct __user *)arg, sizeof(ioctl_struct)))",
            "        return -EFAULT;",
            "      printk(KERN_INFO \"Received struct: id=%d, name=%s\\n\", ioctl_struct.id, ioctl_struct.name);",
            "      break;",
            "    default:",
            "      return -ENOTTY;",
            "  }",
            "  return 0;",
            "}",
            "",
            "static int my_open(struct inode *inode, struct file *file) {",
            "  printk(KERN_INFO \"Device opened\\n\");",
            "  return 0;",
            "}",
            "",
            "static int my_release(struct inode *inode, struct file *file) {",
            "  printk(KERN_INFO \"Device closed\\n\");",
            "  return 0;",
            "}",
            "",
            "static struct file_operations fops = {",
            "  .owner = THIS_MODULE,",
            "  .open = my_open,",
            "  .release = my_release,",
            "  .unlocked_ioctl = my_ioctl",
            "};",
            "",
            "static int __init my_ioctl_init(void) {",
            "  alloc_chrdev_region(&dev, 0, 1, \"my_ioctl_dev\");",
            "  cdev_init(&my_cdev, &fops);",
            "  cdev_add(&my_cdev, dev, 1);",
            "",
            "  dev_class = class_create(\"my_class\");",
            "  dev_device = device_create(dev_class, NULL, dev, NULL, \"my_dev\");",
            "",
            "  printk(KERN_INFO \"IOCTL Device registered: Major %d Minor %d\\n\", MAJOR(dev), MINOR(dev));",
            "  return 0;",
            "}",
            "",
            "static void __exit my_ioctl_exit(void) {",
            "  device_destroy(dev_class, dev);",
            "  class_destroy(dev_class);",
            "  cdev_del(&my_cdev);",
            "  unregister_chrdev_region(dev, 1);",
            "  printk(KERN_INFO \"IOCTL Device unregistered\\n\");",
            "}",
            "",
            "module_init(my_ioctl_init);",
            "module_exit(my_ioctl_exit);",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"A simple IOCTL-based character driver with device node creation\");"
        ],
        "description": "IOCTL driver with struct passing and device node creation using class_create and device_create."
    },
    "ld_ioctl_userspace": {
        "prefix": "ld_userspace_ioctl",
        "body": [
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "",
            "#include \"ioctl_func.h\"",
            "",
            "#define DEVICE_PATH \"/dev/my_ioctl_dev\"",
            "",
            "int main() {",
            "    int fd;",
            "    int val = 42;",
            "    struct my_struct data = { .id = 101, .name = \"Mukesh\" };",
            "",
            "    fd = open(DEVICE_PATH, O_RDWR);",
            "    if (fd < 0) {",
            "        perror(\"Failed to open device\");",
            "        return EXIT_FAILURE;",
            "    }",
            "",
            "    // Send int value to kernel",
            "    if (ioctl(fd, WR_VALUE, &val) < 0) {",
            "        perror(\"WR_VALUE ioctl failed\");",
            "    }",
            "",
            "    // Read int value from kernel",
            "    val = 0;",
            "    if (ioctl(fd, RD_VALUE, &val) < 0) {",
            "        perror(\"RD_VALUE ioctl failed\");",
            "    } else {",
            "        printf(\"Value received from kernel: %d\\n\", val);",
            "    }",
            "",
            "    // Send struct to kernel",
            "    if (ioctl(fd, Greeter, &data) < 0) {",
            "        perror(\"Greeter ioctl failed\");",
            "    }",
            "",
            "    close(fd);",
            "    return EXIT_SUCCESS;",
            "}"
        ],
        "description": "Userspace IOCTL: send/receive data and send struct to kernel module"
    },
    "ld_threads_multi": {
        "prefix": "ld_threads_multi",
        "body": [
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "",
            "static struct task_struct *kthread_1;",
            "static struct task_struct *kthread_2;",
            "static int t1 = 1, t2 = 2;",
            "",
            "int thread_function(void *thread_no) {",
            "  unsigned int i = 0;",
            "  int t_no = *(int *)thread_no;",
            "  while (!kthread_should_stop()) {",
            "    printk(KERN_INFO \"Kernel Thread %d is executed conter val: %d\\n\", t_no, i++);",
            "    msleep(t_no * 1000);",
            "  }",
            "  printk(KERN_INFO \"Kernel Thread %d finised execution\", t_no);",
            "  return 0;",
            "}",
            "",
            "static int __init my_thread_init(void) {",
            "  printk(KERN_INFO \"Init kthread\\n\");",
            "  kthread_1 = kthread_create(thread_function, &t1, \"kthread_1\");",
            "  if (kthread_1 != NULL) {",
            "    wake_up_process(kthread_1);",
            "    printk(KERN_INFO \"Kernel Thread 1 has been created and running now.\\n\");",
            "  } else {",
            "    printk(KERN_ERR \"Kernel Thread 1 could not be created.\\n\");",
            "    return -1;",
            "  }",
            "  kthread_2 = kthread_run(thread_function, &t2, \"kthread_2\");",
            "  if (kthread_2 != NULL) {",
            "    printk(KERN_INFO \"Kernel Thread 2 has been created and running now.\\n\");",
            "  } else {",
            "    printk(KERN_INFO \"Kernel Thread 2 could not be created.\\n\");",
            "    kthread_stop(kthread_2);",
            "    return -1;",
            "  }",
            "  printk(KERN_INFO \"Both Kernel Threads are running now.\\n\");",
            "  return 0;",
            "}",
            "",
            "static void __exit my_thread_exit(void) {",
            "  printk(KERN_INFO \"Stopping threads\\n\");",
            "  kthread_stop(kthread_1);",
            "  kthread_stop(kthread_2);",
            "}",
            "",
            "module_init(hello_init);",
            "module_exit(hello_exit);",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Name\");",
            "MODULE_DESCRIPTION(\"A simple thread functions\");"
        ],
        "description": "A kernel module that creates and manages two kernel threads with different delays."
    },
    "ld_signal_on_read": {
        "prefix": "ld_signal",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include <linux/cdev.h>",
            "#include <linux/device.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/signal.h>",
            "",
            "static dev_t dev;",
            "static struct cdev my_cdev;",
            "static struct class *dev_class;",
            "static struct device *dev_device;",
            "static struct task_struct *user_task = NULL;",
            "static int pid = -1;",
            "",
            "static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {",
            "    if (copy_from_user(&pid, (int __user *)arg, sizeof(int)))",
            "        return -EFAULT;",
            "    user_task = pid_task(find_vpid(pid), PIDTYPE_PID);",
            "    if (!user_task) return -EINVAL;",
            "    printk(KERN_INFO \"Received PID: %d\\n\", pid);",
            "    return 0;",
            "}",
            "",
            "static ssize_t my_read(struct file *file, char __user *buf, size_t len, loff_t *offset) {",
            "    struct kernel_siginfo info;",
            "    memset(&info, 0, sizeof(struct kernel_siginfo));",
            "    info.si_signo = SIGUSR1;",
            "    info.si_code = SI_QUEUE;",
            "    info.si_int = 2024;",
            "",
            "    if (user_task) {",
            "        if (send_sig_info(SIGUSR1, (struct kernel_siginfo *)&info, user_task) < 0)",
            "            printk(KERN_ERR \"Failed to send signal\\n\");",
            "        else",
            "            printk(KERN_INFO \"Signal sent to PID: %d\\n\", pid);",
            "    }",
            "    return 0;",
            "}",
            "",
            "static struct file_operations fops = {",
            "    .owner = THIS_MODULE,",
            "    .unlocked_ioctl = my_ioctl,",
            "    .read = my_read,",
            "};",
            "",
            "static int __init my_init(void) {",
            "    printk(KERN_INFO \"Signal on read module init\\n\");",
            "    alloc_chrdev_region(&dev, 0, 1, \"signal_dev\");",
            "    cdev_init(&my_cdev, &fops);",
            "    cdev_add(&my_cdev, dev, 1);",
            "    dev_class = class_create(\"signal_class\");",
            "    dev_device = device_create(dev_class, NULL, dev, NULL, \"signal_dev\");",
            "    return 0;",
            "}",
            "",
            "static void __exit my_exit(void) {",
            "    device_destroy(dev_class, dev);",
            "    class_destroy(dev_class);",
            "    cdev_del(&my_cdev);",
            "    unregister_chrdev_region(dev, 1);",
            "    printk(KERN_INFO \"Signal sender module exit\\n\");",
            "}",
            "",
            "module_init(my_init);",
            "module_exit(my_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"mmkumr\");",
            "MODULE_DESCRIPTION(\"Signal sent to user-space on read\");"
        ],
        "description": "Kernel module that sends signal to userspace on read() call"
    },
    "ld_signal_userspace": {
        "prefix": "ld_signal_userspace",
        "body": [
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "",
            "#define DEVICE_PATH \"/dev/signal_dev\"",
            "",
            "void signal_handler(int sig, siginfo_t *info, void *context) {",
            "    printf(\"Received signal: %d from kernel\\n\", sig);",
            "    printf(\"Signal data (si_int): %d\\n\", info->si_int);",
            "}",
            "",
            "int main() {",
            "    int fd, pid = getpid();",
            "    struct sigaction act;",
            "",
            "    memset(&act, 0, sizeof(act));",
            "    act.sa_sigaction = signal_handler;",
            "    act.sa_flags = SA_SIGINFO;",
            "    sigaction(SIGUSR1, &act, NULL);",
            "",
            "    fd = open(DEVICE_PATH, O_RDONLY);",
            "    if (fd < 0) { perror(\"Open failed\"); return 1; }",
            "",
            "    if (ioctl(fd, 0, &pid) < 0) {",
            "        perror(\"IOCTL failed\");",
            "        close(fd);",
            "        return 1;",
            "    }",
            "",
            "    printf(\"PID sent. Reading to trigger signal...\\n\");",
            "    char buf[1];",
            "    read(fd, buf, 1);",
            "",
            "    pause(); // Wait for signal",
            "    close(fd);",
            "    return 0;",
            "}"
        ],
        "description": "User program to receive signal from kernel module on read"
    },
    "ld_proc_rw": {
        "prefix": "ld_proc_rw",
        "body": [
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "",
            "#define PROC_FOLDER \"my_folder\"",
            "#define PROC_FILE \"my_procfile\"",
            "#define BUF_SIZE 128",
            "",
            "static struct proc_dir_entry *parent_dir = NULL;",
            "static struct proc_dir_entry *proc_file = NULL;",
            "static char proc_data[BUF_SIZE] = \"Hello from kernel\";",
            "",
            "static ssize_t proc_read(struct file *file, char __user *buf, size_t count, loff_t *ppos) {",
            "    return simple_read_from_buffer(buf, count, ppos, proc_data, strlen(proc_data));",
            "}",
            "",
            "static ssize_t proc_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos) {",
            "    if (count > BUF_SIZE - 1) count = BUF_SIZE - 1;",
            "    if (copy_from_user(proc_data, buf, count))",
            "        return -EFAULT;",
            "    proc_data[count] = '\\0';",
            "    printk(KERN_INFO \"[proc_write] New data: %s\\n\", proc_data);",
            "    return count;",
            "}",
            "",
            "static const struct proc_ops proc_fops = {",
            "    .proc_read = proc_read,",
            "    .proc_write = proc_write,",
            "};",
            "",
            "static int __init proc_init(void) {",
            "    parent_dir = proc_mkdir(PROC_FOLDER, NULL);",
            "    if (!parent_dir) {",
            "        printk(KERN_ERR \"[proc_init] Failed to create /proc/%s\\n\", PROC_FOLDER);",
            "        return -ENOMEM;",
            "    }",
            "",
            "    proc_file = proc_create(PROC_FILE, 0666, parent_dir, &proc_fops);",
            "    if (!proc_file) {",
            "        printk(KERN_ERR \"[proc_init] Failed to create /proc/%s/%s\\n\", PROC_FOLDER, PROC_FILE);",
            "        proc_remove(parent_dir);",
            "        return -ENOMEM;",
            "    }",
            "",
            "    printk(KERN_INFO \"[proc_init] /proc/%s/%s created\\n\", PROC_FOLDER, PROC_FILE);",
            "    return 0;",
            "}",
            "",
            "static void __exit proc_exit(void) {",
            "    proc_remove(proc_file);",
            "    proc_remove(parent_dir);",
            "    printk(KERN_INFO \"[proc_exit] /proc/%s/%s removed\\n\", PROC_FOLDER, PROC_FILE);",
            "}",
            "",
            "module_init(proc_init);",
            "module_exit(proc_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"mmkumr\");",
            "MODULE_DESCRIPTION(\"Procfs with read/write inside a folder\");"
        ],
        "description": "Creates a /proc/my_folder/my_procfile with read/write support"
    },
    "ld_sysfs_rw": {
        "prefix": "ld_sysfs_rw",
        "body": [
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kobject.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/string.h>",
            "",
            "static struct kobject *kobj_ref;",
            "static char sysfs_data[128] = \"Default data\";",
            "",
            "static ssize_t sysfs_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf) {",
            "    return sprintf(buf, \"%s\\n\", sysfs_data);",
            "}",
            "",
            "static ssize_t sysfs_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count) {",
            "    snprintf(sysfs_data, sizeof(sysfs_data), \"%.*s\", (int)count, buf);",
            "    printk(KERN_INFO \"[sysfs_store] Updated data: %s\\n\", sysfs_data);",
            "    return count;",
            "}",
            "",
            "static struct kobj_attribute sysfs_attr = __ATTR(my_sysfs_entry, 0660, sysfs_show, sysfs_store);",
            "",
            "static int __init sysfs_module_init(void) {",
            "    kobj_ref = kobject_create_and_add(\"my_kobj\", kernel_kobj);",
            "    if (!kobj_ref)",
            "        return -ENOMEM;",
            "    if (sysfs_create_file(kobj_ref, &sysfs_attr.attr)) {",
            "        kobject_put(kobj_ref);",
            "        return -EINVAL;",
            "    }",
            "    printk(KERN_INFO \"[sysfs] /sys/kernel/my_kobj/my_sysfs_entry created\\n\");",
            "    return 0;",
            "}",
            "",
            "static void __exit sysfs_module_exit(void) {",
            "    sysfs_remove_file(kobj_ref, &sysfs_attr.attr);",
            "    kobject_put(kobj_ref);",
            "    printk(KERN_INFO \"[sysfs] Sysfs entry removed\\n\");",
            "}",
            "",
            "module_init(sysfs_module_init);",
            "module_exit(sysfs_module_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"mmkumr\");",
            "MODULE_DESCRIPTION(\"Sysfs read/write entry under /sys/kernel\");"
        ],
        "description": "Creates a clean /sys/kernel/my_kobj/my_sysfs_entry with read/write"
    },
    "serdev echo kernel module": {
        "prefix": "ld_uart",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/serdev.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/property.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/of_device.h>",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"${1:Your Name}\");",
            "MODULE_DESCRIPTION(\"${2:Simple UART serdev echo driver}\");",
            "",
            "static int ${3:my_probe}(struct serdev_device *serdev);",
            "static void ${4:my_remove}(struct serdev_device *serdev);",
            "",
            "static struct of_device_id ${5:my_driver_ids}[] = {",
            "  { .compatible = \"${6:brightlight,echodev}\" },",
            "  { }",
            "};",
            "MODULE_DEVICE_TABLE(of, ${5:my_driver_ids});",
            "",
            "static struct serdev_device_driver ${7:my_driver} = {",
            "  .probe = ${3:my_probe},",
            "  .remove = ${4:my_remove},",
            "  .driver = {",
            "    .name = \"${8:serdev-echo}\",",
            "    .of_match_table = ${5:my_driver_ids},",
            "  },",
            "};",
            "",
            "static int ${9:recv_callback}(struct serdev_device *serdev, const unsigned char *buffer, size_t size) {",
            "  printk(KERN_INFO \"${8:serdev-echo} - Received %ld bytes: %s\\n\", size, buffer);",
            "  return serdev_device_write_buf(serdev, buffer, size);",
            "}",
            "",
            "static const struct serdev_device_ops ${10:my_ops} = {",
            "  .receive_buf = ${9:recv_callback},",
            "};",
            "",
            "static int ${3:my_probe}(struct serdev_device *serdev) {",
            "  int status;",
            "  printk(KERN_INFO \"${8:serdev-echo} - Probing device\\n\");",
            "  serdev_device_set_client_ops(serdev, &${10:my_ops});",
            "  status = serdev_device_open(serdev);",
            "  if (status) {",
            "    printk(KERN_ERR \"${8:serdev-echo} - Failed to open serdev\\n\");",
            "    return -status;",
            "  }",
            "  serdev_device_set_baudrate(serdev, ${11:9600});",
            "  serdev_device_set_flow_control(serdev, false);",
            "  serdev_device_set_parity(serdev, SERDEV_PARITY_NONE);",
            "  status = serdev_device_write_buf(serdev, \"${12:Type something: }\", sizeof(\"${12:Type something: }\"));",
            "  printk(KERN_INFO \"${8:serdev-echo} - Wrote %d bytes\\n\", status);",
            "  return 0;",
            "}",
            "",
            "static void ${4:my_remove}(struct serdev_device *serdev) {",
            "  printk(KERN_INFO \"${8:serdev-echo} - Removing driver\\n\");",
            "  serdev_device_close(serdev);",
            "}",
            "",
            "static int __init ${13:init_func}(void) {",
            "  printk(KERN_INFO \"${8:serdev-echo} - Initializing driver\\n\");",
            "  return serdev_device_driver_register(&${7:my_driver});",
            "}",
            "",
            "static void __exit ${14:exit_func}(void) {",
            "  printk(KERN_INFO \"${8:serdev-echo} - Exiting driver\\n\");",
            "  serdev_device_driver_unregister(&${7:my_driver});",
            "}",
            "",
            "module_init(${13:init_func});",
            "module_exit(${14:exit_func});"
        ],
        "description": "UART serdev loopback kernel module with placeholders"
    },
    "DMA Memcpy Kernel Module": {
        "prefix": "ld_direct_memory_access",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/dmaengine.h>",
            "#include <linux/dma-mapping.h>",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"${1:Your Name}\");",
            "MODULE_DESCRIPTION(\"${2:RAM to RAM DMA memory copy}\");",
            "",
            "void ${3:dma_transfer_completed}(void *param) {",
            "  struct completion *cmp = (struct completion *)param;",
            "  complete(cmp);",
            "}",
            "",
            "static int __init ${4:my_init}(void) {",
            "  dma_cap_mask_t mask;",
            "  struct dma_chan *chan;",
            "  struct dma_async_tx_descriptor *chan_desc;",
            "  dma_cookie_t cookie;",
            "  dma_addr_t src_addr, dst_addr;",
            "  u8 *src_buf, *dst_buf;",
            "  struct completion cmp;",
            "  int status;",
            "",
            "  printk(KERN_INFO \"dma_memcpy - Init\\n\");",
            "",
            "  dma_cap_zero(mask);",
            "  dma_cap_set(DMA_SLAVE | DMA_PRIVATE, mask);",
            "  chan = dma_request_channel(mask, NULL, NULL);",
            "  if (!chan) {",
            "    printk(KERN_ERR \"dma_memcpy - Failed to request DMA channel\\n\");",
            "    return -ENODEV;",
            "  }",
            "",
            "  src_buf = dma_alloc_coherent(chan->device->dev, 1024, &src_addr, GFP_KERNEL);",
            "  dst_buf = dma_alloc_coherent(chan->device->dev, 1024, &dst_addr, GFP_KERNEL);",
            "",
            "  memset(src_buf, 0x12, 1024);",
            "  memset(dst_buf, 0x00, 1024);",
            "",
            "  printk(KERN_INFO \"dma_memcpy - Before Transfer: src_buf[0] = %x\\n\", src_buf[0]);",
            "  printk(KERN_INFO \"dma_memcpy - Before Transfer: dst_buf[0] = %x\\n\", dst_buf[0]);",
            "",
            "  chan_desc = dmaengine_prep_dma_memcpy(chan, dst_addr, src_addr, 1024, DMA_MEM_TO_MEM);",
            "  if (!chan_desc) {",
            "    printk(KERN_ERR \"dma_memcpy - Failed to prepare DMA memcpy\\n\");",
            "    status = -1;",
            "    goto free;",
            "  }",
            "",
            "  init_completion(&cmp);",
            "  chan_desc->callback = ${3:dma_transfer_completed};",
            "  chan_desc->callback_param = &cmp;",
            "  cookie = dmaengine_submit(chan_desc);",
            "  dma_async_issue_pending(chan);",
            "",
            "  if (wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000)) <= 0) {",
            "    printk(KERN_ERR \"dma_memcpy - Timeout waiting for completion\\n\");",
            "    status = -1;",
            "  }",
            "",
            "  status = dma_async_is_tx_complete(chan, cookie, NULL, NULL);",
            "  if (status == DMA_COMPLETE) {",
            "    printk(KERN_INFO \"dma_memcpy - Transfer completed successfully!\\n\");",
            "    printk(KERN_INFO \"dma_memcpy - After Transfer: src_buf[0] = %x\\n\", src_buf[0]);",
            "    printk(KERN_INFO \"dma_memcpy - After Transfer: dst_buf[0] = %x\\n\", dst_buf[0]);",
            "    status = 0;",
            "  } else {",
            "    printk(KERN_ERR \"dma_memcpy - Transfer failed\\n\");",
            "  }",
            "",
            "  dmaengine_terminate_all(chan);",
            "free:",
            "  dma_free_coherent(chan->device->dev, 1024, src_buf, src_addr);",
            "  dma_free_coherent(chan->device->dev, 1024, dst_buf, dst_addr);",
            "  dma_release_channel(chan);",
            "  return status;",
            "}",
            "",
            "static void __exit ${5:my_exit}(void) {",
            "  printk(KERN_INFO \"dma_memcpy - Exit\\n\");",
            "}",
            "",
            "module_init(${4:my_init});",
            "module_exit(${5:my_exit});"
        ],
        "description": "Linux kernel module for DMA memcpy using completion"
    },
    "ld_mmap driver": {
        "prefix": "ld_mmap",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <asm/page.h>",
            "#include <asm/io.h>",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"${1:Author Name}\");",
            "MODULE_DESCRIPTION(\"${2:A simple mmap example}\");",
            "",
            "#define MYMAJOR ${3:64}",
            "#define DEVNAME \"${4:mydev}\"",
            "",
            "static void *my_data;",
            "",
            "static ssize_t my_read(struct file *file, char __user *user_buffer, size_t len, loff_t *offs) {",
            "  int not_copied, to_copy = (len > PAGE_SIZE) ? PAGE_SIZE : len;",
            "  not_copied = copy_to_user(user_buffer, my_data, to_copy);",
            "  return to_copy - not_copied;",
            "}",
            "",
            "static ssize_t my_write(struct file *file, const char __user *user_buffer, size_t len, loff_t *offs) {",
            "  int not_copied, to_copy = (len > PAGE_SIZE) ? PAGE_SIZE : len;",
            "  not_copied = copy_from_user(my_data, user_buffer, to_copy);",
            "  return to_copy - not_copied;",
            "}",
            "",
            "static int my_mmap(struct file *file, struct vm_area_struct *vma) {",
            "  int status;",
            "  vma->vm_pgoff = virt_to_phys(my_data) >> PAGE_SHIFT;",
            "  status = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,",
            "                           vma->vm_end - vma->vm_start, vma->vm_page_prot);",
            "  if (status) {",
            "    printk(\"my_mmap - Error remap_pfn_range: %d\\n\", status);",
            "    return -EAGAIN;",
            "  }",
            "  return 0;",
            "}",
            "",
            "static struct file_operations fops = {",
            "  .owner = THIS_MODULE,",
            "  .read = my_read,",
            "  .write = my_write,",
            "  .mmap = my_mmap,",
            "};",
            "",
            "static int __init my_init(void) {",
            "  int status;",
            "  printk(\"my_mmap - Init\\n\");",
            "  my_data = kzalloc(PAGE_SIZE, GFP_DMA);",
            "  if (!my_data) return -ENOMEM;",
            "",
            "  status = register_chrdev(MYMAJOR, DEVNAME, &fops);",
            "  if (status < 0) {",
            "    printk(\"my_mmap - Error registering device!\\n\");",
            "    kfree(my_data);",
            "    return status;",
            "  }",
            "  return 0;",
            "}",
            "",
            "static void __exit my_exit(void) {",
            "  if (my_data) kfree(my_data);",
            "  unregister_chrdev(MYMAJOR, DEVNAME);",
            "  printk(\"my_mmap - Exit\\n\");",
            "}",
            "",
            "module_init(my_init);",
            "module_exit(my_exit);"
        ],
        "description": "A simple mmap kernel module with read/write interface"
    },
    "user mmap test program": {
        "prefix": "ld_userspace_mmap",
        "body": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <sys/mman.h>",
            "",
            "#define DEVNAME \"${1:/dev/mydev}\"",
            "",
            "int main(int argc, char **argv) {",
            "  int fd, status, offset;",
            "  char text[4096];",
            "  void *ptr;",
            "",
            "  if(argc < 2) {",
            "    printf(\"Usage: %s [m,r,w,p] {data}\\n\", argv[0]);",
            "    return 0;",
            "  }",
            "",
            "  fd = open(DEVNAME, O_RDWR);",
            "  if(fd < 0) { perror(\"open\"); return 1; }",
            "",
            "  switch(argv[1][0]) {",
            "    case 'r':",
            "      status = read(fd, text, 4096);",
            "      printf(\"READ: I got %d bytes with '%s'\\n\", status, text);",
            "      break;",
            "",
            "    case 'w':",
            "      if(argc < 3) { printf(\"Usage: %s w [data]\\n\", argv[0]); break; }",
            "      memset(text, 0, 4096);",
            "      strcpy(text, argv[2]);",
            "      status = write(fd, text, 4096);",
            "      printf(\"Wrote %d bytes\\n\", status);",
            "      break;",
            "",
            "    case 'm':",
            "      ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);",
            "      if(ptr == MAP_FAILED) { perror(\"mmap\"); break; }",
            "",
            "      if(argc > 2) {",
            "        memset(text, 0, 4096);",
            "        strcpy(text, argv[2]);",
            "        memcpy(ptr, text, 4096);",
            "      }",
            "",
            "      memset(text, 0, 4096);",
            "      memcpy(text, ptr, 4096);",
            "      printf(\"MMAP: I got '%s'\\n\", text);",
            "      munmap(ptr, 4096);",
            "      break;",
            "",
            "    case 'p':",
            "      if(argc < 3) { printf(\"Usage: %s p [offset]\\n\", argv[0]); break; }",
            "      offset = atoi(argv[2]);",
            "      ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);",
            "      if(ptr == MAP_FAILED) { perror(\"mmap\"); break; }",
            "      printf(\"MMAP: Byte on Offset %d: *(ptr + %d) = '%c'\\n\", offset, offset, *((char *)ptr + offset));",
            "      munmap(ptr, 4096);",
            "      break;",
            "",
            "    default:",
            "      printf(\"'%c' is invalid.\\n\", argv[1][0]);",
            "      break;",
            "  }",
            "  close(fd);",
            "}"
        ],
        "description": "User space test program for mmap kernel module"
    },
    "printk log default": {
        "prefix": "printk",
        "body": [
            "printk(\"${1:message}\\n\");"
        ],
        "description": "Basic printk"
    },
    "printk log info": {
        "prefix": "printk_info",
        "body": [
            "printk(KERN_INFO \"${1:info message}\\n\");"
        ],
        "description": "Print an info message"
    },
    "printk log warning": {
        "prefix": "printk_warn",
        "body": [
            "printk(KERN_WARNING \"${1:warning message}\\n\");"
        ],
        "description": "Print a warning message"
    },
    "printk log error": {
        "prefix": "printk_err",
        "body": [
            "printk(KERN_ERR \"${1:error message}\\n\");"
        ],
        "description": "Print an error message"
    },
    "printk log debug": {
        "prefix": "printk_dbg",
        "body": [
            "printk(KERN_DEBUG \"${1:debug message}\\n\");"
        ],
        "description": "Print a debug message"
    },
    "printk log alert": {
        "prefix": "printk_alert",
        "body": [
            "printk(KERN_ALERT \"${1:alert message}\\n\");"
        ],
        "description": "Print an alert message"
    },
    "printk log emergency": {
        "prefix": "printk_emerg",
        "body": [
            "printk(KERN_EMERG \"${1:emergency message}\\n\");"
        ],
        "description": "Print an emergency message"
    },
    "Embedded start main loop": {
        "prefix": "main",
        "body": [
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "",
            "int main(void) {",
            "    ${1:// Initialization}",
            "",
            "    while (1) {",
            "        ${2:// Main loop code}",
            "    }",
            "}"
        ],
        "description": "Embedded C main loop"
    },
    "ISR Template": {
        "prefix": "isr",
        "body": [
            "void __attribute__((interrupt)) ${1:ISR_Handler}(void) {",
            "    ${2:// ISR body}",
            "}"
        ],
        "description": "Interrupt Service Routine (ISR) template"
    },
    "Bit Set": {
        "prefix": "bit_set",
        "body": [
            "${1:REG} |= (1 << ${2:BIT});"
        ],
        "description": "Set a bit in a register"
    },
    "Bit Clear": {
        "prefix": "bit_clear",
        "body": [
            "${1:REG} &= ~(1 << ${2:BIT});"
        ],
        "description": "Clear a bit in a register"
    },
    "Bit Toggle": {
        "prefix": "bit_toggle",
        "body": [
            "${1:REG} ^= (1 << ${2:BIT});"
        ],
        "description": "Toggle a bit in a register"
    },
    "Bit Check": {
        "prefix": "bit_read",
        "body": [
            "if (${1:REG} & (1 << ${2:BIT})) {",
            "    ${3:// bit is set}",
            "}"
        ],
        "description": "Check if a bit is set"
    },
    "Define register": {
        "prefix": "reg",
        "body": [
            "#define ${1:REG_NAME} (*(volatile ${2:uint8_t}*)${3:0x40000000})"
        ],
        "description": "Define memory-mapped register"
    },
    "Delay macro": {
        "prefix": "delay",
        "body": [
            "for (volatile int ${1:i} = 0; $1 < ${2:10000}; ++$1);"
        ],
        "description": "Busy-wait delay loop"
    },
    "Header guard": {
        "prefix": "header_guard",
        "body": [
            "#ifndef ${1:HEADER_NAME}_H",
            "#define $1_H",
            "",
            "${2:// Your code here}",
            "",
            "#endif /* $1_H */"
        ],
        "description": "C header file guard"
    },
    "Interrupt Vector Stub (AVR)": {
        "prefix": "vector",
        "body": [
            "#include <avr/interrupt.h>",
            "",
            "ISR(${1:TIMER1_COMPA_vect}) {",
            "    ${2:// ISR code here}",
            "}"
        ],
        "description": "AVR ISR Vector definition"
    },
    "set pin as output": {
        "prefix": "pin_out",
        "body": [
            "${1:DDRx} |= (1 << ${2:PINx}); // Set pin as output"
        ],
        "description": "Set GPIO pin as output"
    },
    "set pin as input": {
        "prefix": "pin_in",
        "body": [
            "${1:DDRx} &= ~(1 << ${2:PINx}); // Set pin as input"
        ],
        "description": "Set GPIO pin as input"
    },
    "strtok loop": {
        "prefix": "strtok_loop",
        "body": [
            "char ${1:str}[] = \"${2:Mukesh Kumar}\";",
            "char *${3:token};",
            "char *${4:rest} = $1;",
            "",
            "while (($3 = strtok_r($4, \"${5: }\", &$4))) {",
            "  printf(\"%s\\n\", $3);",
            "}"
        ],
        "description": "strtok loop for splitting a string by delimiter"
    }
}
