{
    "Basic Boilerplate": {
        "prefix": "ld_c",
        "body": [
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "",
            "static int __init hello_init(void) {",
            "    printk(KERN_INFO \"Hello, Kernel!\\n\");",
            "    return 0;",
            "}",
            "",
            "static void __exit hello_exit(void) {",
            "    printk(KERN_INFO \"Goodbye, Kernel!\\n\");",
            "}",
            "",
            "module_init(hello_init);",
            "module_exit(hello_exit);",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"A simple Hello World LKM\");"
        ],
        "description": "Minimal Linux Kernel Module"
    },
    "char_device": {
        "prefix": "ld_char",
        "body": [
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "",
            "#define DEVICE_NAME \"mychardev\"",
            "static int major;",
            "",
            "static int dev_open(struct inode *, struct file *);",
            "static int dev_release(struct inode *, struct file *);",
            "static ssize_t dev_read(struct file *, char *, size_t, loff_t *);",
            "static ssize_t dev_write(struct file *, const char *, size_t, loff_t *);",
            "",
            "static struct file_operations fops = {",
            "    .open = dev_open,",
            "    .read = dev_read,",
            "    .write = dev_write,",
            "    .release = dev_release,",
            "};",
            "",
            "static int __init char_init(void) {",
            "    major = register_chrdev(0, DEVICE_NAME, &fops);",
            "    if (major < 0) {",
            "        printk(KERN_ALERT \"Registering char device failed\\n\");",
            "        return major;",
            "    }",
            "    printk(KERN_INFO \"Registered char device with major number %d\\n\", major);",
            "    return 0;",
            "}",
            "",
            "static void __exit char_exit(void) {",
            "    unregister_chrdev(major, DEVICE_NAME);",
            "    printk(KERN_INFO \"Unregistered char device\\n\");",
            "}",
            "",
            "module_init(char_init);",
            "module_exit(char_exit);",
            "",
            "MODULE_LICENSE(\"GPL\");"
        ],
        "description": "Character Device Skeleton"
    },
    "i2c_driver": {
        "prefix": "ld_i2c",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/i2c.h>",
            "",
            "static int my_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id) {",
            "    dev_info(&client->dev, \"I2C device probed\\n\");",
            "    return 0;",
            "}",
            "",
            "static int my_i2c_remove(struct i2c_client *client) {",
            "    dev_info(&client->dev, \"I2C device removed\\n\");",
            "    return 0;",
            "}",
            "",
            "static const struct i2c_device_id my_i2c_id[] = {",
            "    { \"my_i2c_device\", 0 },",
            "    { }",
            "};",
            "MODULE_DEVICE_TABLE(i2c, my_i2c_id);",
            "",
            "static struct i2c_driver my_i2c_driver = {",
            "    .driver = {",
            "        .name = \"my_i2c_driver\",",
            "    },",
            "    .probe = my_i2c_probe,",
            "    .remove = my_i2c_remove,",
            "    .id_table = my_i2c_id,",
            "};",
            "",
            "module_i2c_driver(my_i2c_driver);",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"A simple I2C Driver\");"
        ],
        "description": "Basic I2C Device Driver"
    },
    "Linux SPI Driver Latest": {
        "prefix": "ld_spi",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/spi/spi.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/of.h>",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"${1:Your Name}\");",
            "MODULE_DESCRIPTION(\"SPI device driver example using latest kernel API\");",
            "",
            "static int ${2:spi_dev}_probe(struct spi_device *spi) {",
            "    int ret;",
            "    u8 tx_buf[2] = { 0x75, 0x40 };",
            "    u8 rx_buf[1];",
            "    struct spi_transfer t[] = {",
            "        {",
            "            .tx_buf = tx_buf,",
            "            .len = 1,",
            "        },",
            "        {",
            "            .rx_buf = rx_buf,",
            "            .len = 1,",
            "        }",
            "    };",
            "    struct spi_message m;",
            "",
            "    spi->bits_per_word = 8;",
            "    ret = spi_setup(spi);",
            "    if (ret) {",
            "        dev_err(&spi->dev, \"Failed to setup SPI device: %d\\n\", ret);",
            "        return ret;",
            "    }",
            "",
            "    spi_message_init(&m);",
            "    spi_message_add_tail(&t[0], &m);",
            "    spi_message_add_tail(&t[1], &m);",
            "",
            "    ret = spi_sync(spi, &m);",
            "    if (ret) {",
            "        dev_err(&spi->dev, \"SPI transfer failed: %d\\n\", ret);",
            "        return ret;",
            "    }",
            "",
            "    dev_info(&spi->dev, \"Chip ID read: 0x%02x\\n\", rx_buf[0]);",
            "",
            "    return 0;",
            "}",
            "",
            "static int ${2:spi_dev}_remove(struct spi_device *spi) {",
            "    dev_info(&spi->dev, \"Removing SPI device\\n\");",
            "    return 0;",
            "}",
            "",
            "static const struct of_device_id ${2:spi_dev}_of_match[] = {",
            "    { .compatible = \"bosch,bmp280\", },",
            "    { }",
            "};",
            "MODULE_DEVICE_TABLE(of, ${2:spi_dev}_of_match);",
            "",
            "static struct spi_driver ${2:spi_dev}_driver = {",
            "    .driver = {",
            "        .name = \"${2:spi_dev}\",",
            "        .of_match_table = ${2:spi_dev}_of_match,",
            "    },",
            "    .probe = ${2:spi_dev}_probe,",
            "    .remove = ${2:spi_dev}_remove,",
            "};",
            "",
            "module_spi_driver(${2:spi_dev}_driver);"
        ],
        "description": "SPI driver using probe/remove and spi_sync for latest kernel"
    },
    "hrtimer": {
        "prefix": "ld_hrtimer",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/ktime.h>",
            "",
            "static struct hrtimer hr_timer;",
            "static ktime_t interval;",
            "",
            "enum hrtimer_restart timer_callback(struct hrtimer *timer) {",
            "    printk(KERN_INFO \"hrtimer callback\\n\");",
            "    hrtimer_forward_now(timer, interval);",
            "    return HRTIMER_RESTART;",
            "}",
            "",
            "static int __init hrtimer_init_func(void) {",
            "    interval = ktime_set(0, 500000000);",
            "    hrtimer_init(&hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);",
            "    hr_timer.function = timer_callback;",
            "    hrtimer_start(&hr_timer, interval, HRTIMER_MODE_REL);",
            "    return 0;",
            "}",
            "",
            "static void __exit hrtimer_exit_func(void) {",
            "    hrtimer_cancel(&hr_timer);",
            "}",
            "",
            "module_init(hrtimer_init_func);",
            "module_exit(hrtimer_exit_func);",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"hrtimer example\");"
        ],
        "description": "High Resolution Timer Example"
    },
    "ld_rwop": {
        "prefix": "ld_rwop",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include <linux/cdev.h>",
            "#include <linux/device.h>",
            "",
            "static dev_t dev;",
            "static struct cdev my_cdev;",
            "static struct class *dev_class;",
            "static struct device *dev_device;",
            "",
            "char kbuf[128] = \"Hello from kernel!\";",
            "",
            "static int my_open(struct inode *inode, struct file *file) {",
            "    printk(KERN_INFO \"Device opened\\n\");",
            "    return 0;",
            "}",
            "",
            "static int my_release(struct inode *inode, struct file *file) {",
            "    printk(KERN_INFO \"Device released\\n\");",
            "    return 0;",
            "}",
            "",
            "static ssize_t my_read(struct file *file, char __user *buf, size_t len, loff_t *offset) {",
            "    int datalen = sizeof(kbuf);",
            "    if (*offset >= datalen) return 0;",
            "    if (len > datalen - *offset) len = datalen - *offset;",
            "    if (copy_to_user(buf, kbuf + *offset, len)) return -EFAULT;",
            "    *offset += len;",
            "    return len;",
            "}",
            "",
            "static ssize_t my_write(struct file *file, const char __user *buf, size_t len, loff_t *offset) {",
            "    if (len > 127) len = 127;",
            "    if (copy_from_user(kbuf, buf, len)) return -EFAULT;",
            "    kbuf[len] = '\\0';",
            "    printk(KERN_INFO \"Received from user: %s\\n\", kbuf);",
            "    return len;",
            "}",
            "",
            "static struct file_operations fops = {",
            "    .owner = THIS_MODULE,",
            "    .open = my_open,",
            "    .release = my_release,",
            "    .read = my_read,",
            "    .write = my_write,",
            "};",
            "",
            "static int __init my_init(void) {",
            "    alloc_chrdev_region(&dev, 0, 1, \"my_rwdev\");",
            "    cdev_init(&my_cdev, &fops);",
            "    cdev_add(&my_cdev, dev, 1);",
            "",
            "    dev_class = class_create(THIS_MODULE, \"rw_class\");",
            "    dev_device = device_create(dev_class, NULL, dev, NULL, \"rw_dev\");",
            "",
            "    printk(KERN_INFO \"Device registered: Major=%d Minor=%d\\n\", MAJOR(dev), MINOR(dev));",
            "    return 0;",
            "}",
            "",
            "static void __exit my_exit(void) {",
            "    device_destroy(dev_class, dev);",
            "    class_destroy(dev_class);",
            "    cdev_del(&my_cdev);",
            "    unregister_chrdev_region(dev, 1);",
            "    printk(KERN_INFO \"Device unregistered\\n\");",
            "}",
            "",
            "module_init(my_init);",
            "module_exit(my_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"Read, Write, Open, Release file operations with device node creation\");"
        ],
        "description": "Read, write, open, release function definitions and file_operations struct with device node creation"
    },
    "ld_userspace_rw": {
        "prefix": "ld_rwop_userspace",
        "body": [
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "",
            "#define DEVICE_PATH \"/dev/rw_dev\"",
            "",
            "int main() {",
            "    int fd;",
            "    char write_buf[100] = \"Hello Kernel from User!\";",
            "    char read_buf[100];",
            "",
            "    // Open the device file",
            "    fd = open(DEVICE_PATH, O_RDWR);",
            "    if (fd < 0) {",
            "        perror(\"Failed to open the device\");",
            "        return EXIT_FAILURE;",
            "    }",
            "",
            "    // Write to the device",
            "    if (write(fd, write_buf, strlen(write_buf)) < 0) {",
            "        perror(\"Failed to write to the device\");",
            "        close(fd);",
            "        return EXIT_FAILURE;",
            "    }",
            "    printf(\"Data written: %s\\n\", write_buf);",
            "",
            "    // Read from the device",
            "    memset(read_buf, 0, sizeof(read_buf));",
            "    if (read(fd, read_buf, sizeof(read_buf)) < 0) {",
            "        perror(\"Failed to read from the device\");",
            "        close(fd);",
            "        return EXIT_FAILURE;",
            "    }",
            "    printf(\"Data read: %s\\n\", read_buf);",
            "",
            "    close(fd);",
            "    return EXIT_SUCCESS;",
            "}"
        ],
        "description": "Userspace program to perform read/write on a character device file."
    },
    "ld_gpio": {
        "prefix": "ld_gpio",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gpio.h>",
            "#include <linux/init.h>",
            "\n",
            "#define GPIO_NUM 24 // Replace with your GPIO number",
            "\n",
            "static int __init gpio_init(void) {",
            "  int ret;",
            "\n",
            "  ret = gpio_request(GPIO_NUM, \"my_gpio\");",
            "  if (ret) {",
            "    printk(KERN_ERR \"Failed to request GPIO %d\\n\", GPIO_NUM);",
            "    return ret;",
            "  }",
            "\n",
            "  ret = gpio_direction_output(GPIO_NUM, 1);",
            "  if (ret) {",
            "    printk(KERN_ERR \"Failed to set GPIO direction\\n\");",
            "    gpio_free(GPIO_NUM);",
            "    return ret;",
            "  }",
            "\n",
            "  printk(KERN_INFO \"GPIO %d initialized\\n\", GPIO_NUM);",
            "  return 0;",
            "}",
            "\n",
            "static void __exit gpio_exit(void) {",
            "  gpio_set_value(GPIO_NUM, 0);",
            "  gpio_free(GPIO_NUM);",
            "  printk(KERN_INFO \"GPIO %d released\\n\", GPIO_NUM);",
            "}",
            "\n",
            "module_init(gpio_init);",
            "module_exit(gpio_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"GPIO Driver Skeleton\");"
        ],
        "description": "GPIO driver skeleton for basic GPIO operations."
    },
    "GPIO Interrupt Handler": {
        "prefix": "ld_gpio_irq",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/gpio.h>",
            "#include <linux/interrupt.h>",
            "",
            "#define GPIO_IN ${1:17} // Replace with your GPIO pin number",
            "static unsigned int gpio_irq_number;",
            "",
            "static irqreturn_t gpio_irq_handler(int irq, void *dev_id) {",
            "    printk(KERN_INFO \"GPIO Interrupt occurred!\\n\");",
            "    return IRQ_HANDLED;",
            "}",
            "",
            "static int __init gpio_irq_init(void) {",
            "    int result = 0;",
            "",
            "    if (!gpio_is_valid(GPIO_IN)) {",
            "        printk(KERN_ERR \"Invalid GPIO %d\\n\", GPIO_IN);",
            "        return -ENODEV;",
            "    }",
            "",
            "    gpio_request(GPIO_IN, \"sysfs\");",
            "    gpio_direction_input(GPIO_IN);",
            "    gpio_irq_number = gpio_to_irq(GPIO_IN);",
            "    printk(KERN_INFO \"GPIO mapped to IRQ: %d\\n\", gpio_irq_number);",
            "",
            "    result = request_irq(gpio_irq_number,",
            "                         (irq_handler_t) gpio_irq_handler,",
            "                         IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,",
            "                         \"gpio_irq_handler\",",
            "                         NULL);",
            "",
            "    if (result) {",
            "        printk(KERN_ERR \"IRQ request failed\\n\");",
            "        gpio_unexport(GPIO_IN);",
            "        gpio_free(GPIO_IN);",
            "        return result;",
            "    }",
            "",
            "    printk(KERN_INFO \"GPIO IRQ module loaded\\n\");",
            "    return 0;",
            "}",
            "",
            "static void __exit gpio_irq_exit(void) {",
            "    free_irq(gpio_irq_number, NULL);",
            "    gpio_free(GPIO_IN);",
            "    printk(KERN_INFO \"GPIO IRQ module unloaded\\n\");",
            "}",
            "",
            "module_init(gpio_irq_init);",
            "module_exit(gpio_irq_exit);",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"GPIO Interrupt Handler Kernel Module\");"
        ],
        "description": "GPIO interrupt-based kernel module skeleton"
    },
    "ld_pwm": {
        "prefix": "ld_pwm",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/pwm.h>",
            "#include <linux/err.h>",
            "\n",
            "static struct pwm_device *pwm;",
            "\n",
            "static int __init pwm_example_init(void) {",
            "  int ret;",
            "  pwm = pwm_request(0, \"my_pwm\");",
            "  if (IS_ERR(pwm)) {",
            "    pr_err(\"Failed to request PWM\\n\");",
            "    return PTR_ERR(pwm);",
            "  }",
            "  ret = pwm_config(pwm, 500000, 1000000);  // 50% duty cycle, 1ms period",
            "  if (ret < 0) {",
            "    pr_err(\"Failed to configure PWM\\n\");",
            "    pwm_free(pwm);",
            "    return ret;",
            "  }",
            "  pwm_enable(pwm);",
            "  pr_info(\"PWM enabled\\n\");",
            "  return 0;",
            "}",
            "\n",
            "static void __exit pwm_example_exit(void) {",
            "  pwm_disable(pwm);",
            "  pwm_free(pwm);",
            "  pr_info(\"PWM disabled and freed\\n\");",
            "}",
            "\n",
            "module_init(pwm_example_init);",
            "module_exit(pwm_example_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"Simple PWM example driver\");"
        ],
        "description": "Basic PWM driver example using pwm_request, pwm_config, pwm_enable."
    },
    "ld_uart": {
        "prefix": "ld_uart",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/tty.h>",
            "#include <linux/tty_flip.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/platform_device.h>",
            "\n",
            "static struct uart_port my_uart_port;",
            "\n",
            "static int my_uart_startup(struct uart_port *port) {",
            "  pr_info(\"UART startup\\n\");",
            "  // Add hardware initialization here",
            "  return 0;",
            "}",
            "\n",
            "static void my_uart_shutdown(struct uart_port *port) {",
            "  pr_info(\"UART shutdown\\n\");",
            "  // Add hardware shutdown here",
            "}",
            "\n",
            "static unsigned int my_uart_tx_empty(struct uart_port *port) {",
            "  return TIOCSER_TEMT;  // Transmitter empty",
            "}",
            "\n",
            "static void my_uart_set_mctrl(struct uart_port *port, unsigned int mctrl) {",
            "  pr_info(\"UART set_mctrl: %u\\n\", mctrl);",
            "  // Control modem lines",
            "}",
            "\n",
            "static unsigned int my_uart_get_mctrl(struct uart_port *port) {",
            "  // Return modem status lines",
            "  return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;",
            "}",
            "\n",
            "static void my_uart_stop_tx(struct uart_port *port) {",
            "  pr_info(\"UART stop_tx\\n\");",
            "  // Stop transmitter",
            "}",
            "\n",
            "static void my_uart_start_tx(struct uart_port *port) {",
            "  pr_info(\"UART start_tx\\n\");",
            "  // Start transmitter",
            "}",
            "\n",
            "static void my_uart_stop_rx(struct uart_port *port) {",
            "  pr_info(\"UART stop_rx\\n\");",
            "  // Stop receiver",
            "}",
            "\n",
            "static void my_uart_enable_ms(struct uart_port *port) {",
            "  pr_info(\"UART enable_ms\\n\");",
            "  // Enable modem status interrupts",
            "}",
            "\n",
            "static void my_uart_set_termios(struct uart_port *port, struct ktermios *termios, struct ktermios *old) {",
            "  pr_info(\"UART set_termios\\n\");",
            "  // Set baud rate and other params",
            "}",
            "\n",
            "static const struct uart_ops my_uart_ops = {",
            "  .startup = my_uart_startup,",
            "  .shutdown = my_uart_shutdown,",
            "  .tx_empty = my_uart_tx_empty,",
            "  .set_mctrl = my_uart_set_mctrl,",
            "  .get_mctrl = my_uart_get_mctrl,",
            "  .stop_tx = my_uart_stop_tx,",
            "  .start_tx = my_uart_start_tx,",
            "  .stop_rx = my_uart_stop_rx,",
            "  .enable_ms = my_uart_enable_ms,",
            "  .set_termios = my_uart_set_termios,",
            "};",
            "\n",
            "static struct uart_driver my_uart_driver = {",
            "  .owner = THIS_MODULE,",
            "  .driver_name = \"my_uart_driver\",",
            "  .dev_name = \"ttyMY\",",
            "  .major = 0,",
            "  .minor = 0,",
            "  .nr = 1,",
            "};",
            "\n",
            "static int __init my_uart_init(void) {",
            "  int ret;",
            "  ret = uart_register_driver(&my_uart_driver);",
            "  if (ret) {",
            "    pr_err(\"Failed to register UART driver\\n\");",
            "    return ret;",
            "  }",
            "  memset(&my_uart_port, 0, sizeof(my_uart_port));",
            "  my_uart_port.ops = &my_uart_ops;",
            "  my_uart_port.iotype = UPIO_MEM;",
            "  my_uart_port.flags = UPF_BOOT_AUTOCONF;",
            "  my_uart_port.line = 0;",
            "  // Add additional port setup here",
            "  pr_info(\"UART driver initialized\\n\");",
            "  return 0;",
            "}",
            "\n",
            "static void __exit my_uart_exit(void) {",
            "  uart_unregister_driver(&my_uart_driver);",
            "  pr_info(\"UART driver exited\\n\");",
            "}",
            "\n",
            "module_init(my_uart_init);",
            "module_exit(my_uart_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"Basic UART driver skeleton\");"
        ],
        "description": "Basic UART driver skeleton implementing uart_ops."
    },
    "ld_ioctl": {
        "prefix": "ld_ioctl",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include <linux/cdev.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/device.h>",
            "",
            "// ioctl_func.h",
            "#ifndef IOCT_TEST_H",
            "#define IOCT_TEST_H",
            "struct my_struct {",
            "  int id;",
            "  char name[100];",
            "};",
            "#define WR_VALUE _IOW('a', 'b', int *)",
            "#define RD_VALUE _IOR('a', 'b', int *)",
            "#define Greeter  _IOW('a', 'c', struct my_struct *)",
            "#endif",
            "",
            "static dev_t dev;",
            "static struct cdev my_cdev;",
            "static struct class *dev_class;",
            "static struct device *dev_device;",
            "",
            "int value = 20;",
            "",
            "static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {",
            "  struct my_struct ioctl_struct;",
            "  switch (cmd) {",
            "    case WR_VALUE:",
            "      if (copy_from_user(&value, (int __user *)arg, sizeof(int)))",
            "        return -EFAULT;",
            "      printk(KERN_INFO \"Received IOCTL value: %d\\n\", value);",
            "      break;",
            "    case RD_VALUE:",
            "      if (copy_to_user((int __user *)arg, &value, sizeof(int)))",
            "        return -EFAULT;",
            "      printk(KERN_INFO \"Sent IOCTL value: %d\\n\", value);",
            "      break;",
            "    case Greeter:",
            "      if (copy_from_user(&ioctl_struct, (struct my_struct __user *)arg, sizeof(ioctl_struct)))",
            "        return -EFAULT;",
            "      printk(KERN_INFO \"Received struct: id=%d, name=%s\\n\", ioctl_struct.id, ioctl_struct.name);",
            "      break;",
            "    default:",
            "      return -ENOTTY;",
            "  }",
            "  return 0;",
            "}",
            "",
            "static int my_open(struct inode *inode, struct file *file) {",
            "  printk(KERN_INFO \"Device opened\\n\");",
            "  return 0;",
            "}",
            "",
            "static int my_release(struct inode *inode, struct file *file) {",
            "  printk(KERN_INFO \"Device closed\\n\");",
            "  return 0;",
            "}",
            "",
            "static struct file_operations fops = {",
            "  .owner = THIS_MODULE,",
            "  .open = my_open,",
            "  .release = my_release,",
            "  .unlocked_ioctl = my_ioctl",
            "};",
            "",
            "static int __init my_ioctl_init(void) {",
            "  alloc_chrdev_region(&dev, 0, 1, \"my_ioctl_dev\");",
            "  cdev_init(&my_cdev, &fops);",
            "  cdev_add(&my_cdev, dev, 1);",
            "",
            "  dev_class = class_create(\"my_class\");",
            "  dev_device = device_create(dev_class, NULL, dev, NULL, \"my_dev\");",
            "",
            "  printk(KERN_INFO \"IOCTL Device registered: Major %d Minor %d\\n\", MAJOR(dev), MINOR(dev));",
            "  return 0;",
            "}",
            "",
            "static void __exit my_ioctl_exit(void) {",
            "  device_destroy(dev_class, dev);",
            "  class_destroy(dev_class);",
            "  cdev_del(&my_cdev);",
            "  unregister_chrdev_region(dev, 1);",
            "  printk(KERN_INFO \"IOCTL Device unregistered\\n\");",
            "}",
            "",
            "module_init(my_ioctl_init);",
            "module_exit(my_ioctl_exit);",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Your Name\");",
            "MODULE_DESCRIPTION(\"A simple IOCTL-based character driver with device node creation\");"
        ],
        "description": "IOCTL driver with struct passing and device node creation using class_create and device_create."
    },
    "ld_ioctl_userspace": {
        "prefix": "ld_userspace_ioctl",
        "body": [
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "",
            "#include \"ioctl_func.h\"",
            "",
            "#define DEVICE_PATH \"/dev/my_ioctl_dev\"",
            "",
            "int main() {",
            "    int fd;",
            "    int val = 42;",
            "    struct my_struct data = { .id = 101, .name = \"Mukesh\" };",
            "",
            "    fd = open(DEVICE_PATH, O_RDWR);",
            "    if (fd < 0) {",
            "        perror(\"Failed to open device\");",
            "        return EXIT_FAILURE;",
            "    }",
            "",
            "    // Send int value to kernel",
            "    if (ioctl(fd, WR_VALUE, &val) < 0) {",
            "        perror(\"WR_VALUE ioctl failed\");",
            "    }",
            "",
            "    // Read int value from kernel",
            "    val = 0;",
            "    if (ioctl(fd, RD_VALUE, &val) < 0) {",
            "        perror(\"RD_VALUE ioctl failed\");",
            "    } else {",
            "        printf(\"Value received from kernel: %d\\n\", val);",
            "    }",
            "",
            "    // Send struct to kernel",
            "    if (ioctl(fd, Greeter, &data) < 0) {",
            "        perror(\"Greeter ioctl failed\");",
            "    }",
            "",
            "    close(fd);",
            "    return EXIT_SUCCESS;",
            "}"
        ],
        "description": "Userspace IOCTL example: send/receive data and send struct to kernel module"
    },
    "ld_threads_multi": {
        "prefix": "ld_threads_multi",
        "body": [
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "",
            "static struct task_struct *kthread_1;",
            "static struct task_struct *kthread_2;",
            "static int t1 = 1, t2 = 2;",
            "",
            "int thread_function(void *thread_no) {",
            "  unsigned int i = 0;",
            "  int t_no = *(int *)thread_no;",
            "  while (!kthread_should_stop()) {",
            "    printk(KERN_INFO \"Kernel Thread %d is executed conter val: %d\\n\", t_no, i++);",
            "    msleep(t_no * 1000);",
            "  }",
            "  printk(KERN_INFO \"Kernel Thread %d finised execution\", t_no);",
            "  return 0;",
            "}",
            "",
            "static int __init my_thread_init(void) {",
            "  printk(KERN_INFO \"Init kthread\\n\");",
            "  kthread_1 = kthread_create(thread_function, &t1, \"kthread_1\");",
            "  if (kthread_1 != NULL) {",
            "    wake_up_process(kthread_1);",
            "    printk(KERN_INFO \"Kernel Thread 1 has been created and running now.\\n\");",
            "  } else {",
            "    printk(KERN_ERR \"Kernel Thread 1 could not be created.\\n\");",
            "    return -1;",
            "  }",
            "  kthread_2 = kthread_run(thread_function, &t2, \"kthread_2\");",
            "  if (kthread_2 != NULL) {",
            "    printk(KERN_INFO \"Kernel Thread 2 has been created and running now.\\n\");",
            "  } else {",
            "    printk(KERN_INFO \"Kernel Thread 2 could not be created.\\n\");",
            "    kthread_stop(kthread_2);",
            "    return -1;",
            "  }",
            "  printk(KERN_INFO \"Both Kernel Threads are running now.\\n\");",
            "  return 0;",
            "}",
            "",
            "static void __exit my_thread_exit(void) {",
            "  printk(KERN_INFO \"Stopping threads\\n\");",
            "  kthread_stop(kthread_1);",
            "  kthread_stop(kthread_2);",
            "}",
            "",
            "module_init(hello_init);",
            "module_exit(hello_exit);",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Name\");",
            "MODULE_DESCRIPTION(\"A simple thread functions\");"
        ],
        "description": "A kernel module that creates and manages two kernel threads with different delays."
    },
    "ld_signal_on_read": {
        "prefix": "ld_signal",
        "body": [
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include <linux/cdev.h>",
            "#include <linux/device.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/signal.h>",
            "",
            "static dev_t dev;",
            "static struct cdev my_cdev;",
            "static struct class *dev_class;",
            "static struct device *dev_device;",
            "static struct task_struct *user_task = NULL;",
            "static int pid = -1;",
            "",
            "static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {",
            "    if (copy_from_user(&pid, (int __user *)arg, sizeof(int)))",
            "        return -EFAULT;",
            "    user_task = pid_task(find_vpid(pid), PIDTYPE_PID);",
            "    if (!user_task) return -EINVAL;",
            "    printk(KERN_INFO \"Received PID: %d\\n\", pid);",
            "    return 0;",
            "}",
            "",
            "static ssize_t my_read(struct file *file, char __user *buf, size_t len, loff_t *offset) {",
            "    struct kernel_siginfo info;",
            "    memset(&info, 0, sizeof(struct kernel_siginfo));",
            "    info.si_signo = SIGUSR1;",
            "    info.si_code = SI_QUEUE;",
            "    info.si_int = 2024;",
            "",
            "    if (user_task) {",
            "        if (send_sig_info(SIGUSR1, (struct kernel_siginfo *)&info, user_task) < 0)",
            "            printk(KERN_ERR \"Failed to send signal\\n\");",
            "        else",
            "            printk(KERN_INFO \"Signal sent to PID: %d\\n\", pid);",
            "    }",
            "    return 0;",
            "}",
            "",
            "static struct file_operations fops = {",
            "    .owner = THIS_MODULE,",
            "    .unlocked_ioctl = my_ioctl,",
            "    .read = my_read,",
            "};",
            "",
            "static int __init my_init(void) {",
            "    printk(KERN_INFO \"Signal on read module init\\n\");",
            "    alloc_chrdev_region(&dev, 0, 1, \"signal_dev\");",
            "    cdev_init(&my_cdev, &fops);",
            "    cdev_add(&my_cdev, dev, 1);",
            "    dev_class = class_create(\"signal_class\");",
            "    dev_device = device_create(dev_class, NULL, dev, NULL, \"signal_dev\");",
            "    return 0;",
            "}",
            "",
            "static void __exit my_exit(void) {",
            "    device_destroy(dev_class, dev);",
            "    class_destroy(dev_class);",
            "    cdev_del(&my_cdev);",
            "    unregister_chrdev_region(dev, 1);",
            "    printk(KERN_INFO \"Signal sender module exit\\n\");",
            "}",
            "",
            "module_init(my_init);",
            "module_exit(my_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"mmkumr\");",
            "MODULE_DESCRIPTION(\"Signal sent to user-space on read\");"
        ],
        "description": "Kernel module that sends signal to userspace on read() call"
    },
    "ld_signal_userspace": {
        "prefix": "ld_signal_userspace",
        "body": [
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "",
            "#define DEVICE_PATH \"/dev/signal_dev\"",
            "",
            "void signal_handler(int sig, siginfo_t *info, void *context) {",
            "    printf(\"Received signal: %d from kernel\\n\", sig);",
            "    printf(\"Signal data (si_int): %d\\n\", info->si_int);",
            "}",
            "",
            "int main() {",
            "    int fd, pid = getpid();",
            "    struct sigaction act;",
            "",
            "    memset(&act, 0, sizeof(act));",
            "    act.sa_sigaction = signal_handler;",
            "    act.sa_flags = SA_SIGINFO;",
            "    sigaction(SIGUSR1, &act, NULL);",
            "",
            "    fd = open(DEVICE_PATH, O_RDONLY);",
            "    if (fd < 0) { perror(\"Open failed\"); return 1; }",
            "",
            "    if (ioctl(fd, 0, &pid) < 0) {",
            "        perror(\"IOCTL failed\");",
            "        close(fd);",
            "        return 1;",
            "    }",
            "",
            "    printf(\"PID sent. Reading to trigger signal...\\n\");",
            "    char buf[1];",
            "    read(fd, buf, 1);",
            "",
            "    pause(); // Wait for signal",
            "    close(fd);",
            "    return 0;",
            "}"
        ],
        "description": "User program to receive signal from kernel module on read"
    },
    "ld_proc_rw": {
        "prefix": "ld_proc_rw",
        "body": [
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "",
            "#define PROC_FOLDER \"my_folder\"",
            "#define PROC_FILE \"my_procfile\"",
            "#define BUF_SIZE 128",
            "",
            "static struct proc_dir_entry *parent_dir = NULL;",
            "static struct proc_dir_entry *proc_file = NULL;",
            "static char proc_data[BUF_SIZE] = \"Hello from kernel\";",
            "",
            "static ssize_t proc_read(struct file *file, char __user *buf, size_t count, loff_t *ppos) {",
            "    return simple_read_from_buffer(buf, count, ppos, proc_data, strlen(proc_data));",
            "}",
            "",
            "static ssize_t proc_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos) {",
            "    if (count > BUF_SIZE - 1) count = BUF_SIZE - 1;",
            "    if (copy_from_user(proc_data, buf, count))",
            "        return -EFAULT;",
            "    proc_data[count] = '\\0';",
            "    printk(KERN_INFO \"[proc_write] New data: %s\\n\", proc_data);",
            "    return count;",
            "}",
            "",
            "static const struct proc_ops proc_fops = {",
            "    .proc_read = proc_read,",
            "    .proc_write = proc_write,",
            "};",
            "",
            "static int __init proc_init(void) {",
            "    parent_dir = proc_mkdir(PROC_FOLDER, NULL);",
            "    if (!parent_dir) {",
            "        printk(KERN_ERR \"[proc_init] Failed to create /proc/%s\\n\", PROC_FOLDER);",
            "        return -ENOMEM;",
            "    }",
            "",
            "    proc_file = proc_create(PROC_FILE, 0666, parent_dir, &proc_fops);",
            "    if (!proc_file) {",
            "        printk(KERN_ERR \"[proc_init] Failed to create /proc/%s/%s\\n\", PROC_FOLDER, PROC_FILE);",
            "        proc_remove(parent_dir);",
            "        return -ENOMEM;",
            "    }",
            "",
            "    printk(KERN_INFO \"[proc_init] /proc/%s/%s created\\n\", PROC_FOLDER, PROC_FILE);",
            "    return 0;",
            "}",
            "",
            "static void __exit proc_exit(void) {",
            "    proc_remove(proc_file);",
            "    proc_remove(parent_dir);",
            "    printk(KERN_INFO \"[proc_exit] /proc/%s/%s removed\\n\", PROC_FOLDER, PROC_FILE);",
            "}",
            "",
            "module_init(proc_init);",
            "module_exit(proc_exit);",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"mmkumr\");",
            "MODULE_DESCRIPTION(\"Procfs with read/write inside a folder\");"
        ],
        "description": "Creates a /proc/my_folder/my_procfile with read/write support"
    }
}
